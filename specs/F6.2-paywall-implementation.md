# F6.2: Paywall Implementation

## Objective
Implement paywall UI and define trigger points throughout the app.

## Dependencies
- F6.1 (RevenueCat setup)
- F2.1/F3.1 (Navigation)

## Requirements
- [ ] Paywall screen with product options
- [ ] Price display with localization
- [ ] Monthly vs Annual comparison
- [ ] Purchase button with loading state
- [ ] Restore purchases option
- [ ] Terms and Privacy links
- [ ] Trigger points defined
- [ ] RevenueCat Paywall UI integration (optional)

## Paywall ViewModel

### presentation/paywall/PaywallViewModel.kt
```kotlin
package com.cooleymd.reminders.presentation.paywall

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.cooleymd.reminders.domain.purchase.*
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.launch

class PaywallViewModel(
    private val purchaseManager: PurchaseManager
) : ViewModel() {

    private val _uiState = MutableStateFlow(PaywallUiState())
    val uiState: StateFlow<PaywallUiState> = _uiState.asStateFlow()

    private val _events = MutableSharedFlow<PaywallEvent>()
    val events = _events.asSharedFlow()

    init {
        loadOfferings()
        observePremiumStatus()
    }

    private fun loadOfferings() {
        viewModelScope.launch {
            _uiState.update { it.copy(isLoading = true) }
            purchaseManager.fetchOfferings()

            purchaseManager.offerings.collect { state ->
                when (state) {
                    is OfferingsState.Loading -> {
                        _uiState.update { it.copy(isLoading = true) }
                    }
                    is OfferingsState.Success -> {
                        val defaultOffering = state.offerings.find { it.identifier == "default" }
                        _uiState.update {
                            it.copy(
                                isLoading = false,
                                packages = defaultOffering?.packages ?: emptyList(),
                                selectedPackage = defaultOffering?.packages?.find {
                                    pkg -> pkg.packageType == PackageType.ANNUAL
                                } ?: defaultOffering?.packages?.firstOrNull()
                            )
                        }
                    }
                    is OfferingsState.Error -> {
                        _uiState.update { it.copy(isLoading = false, error = state.message) }
                    }
                }
            }
        }
    }

    private fun observePremiumStatus() {
        viewModelScope.launch {
            purchaseManager.isPremium.collect { isPremium ->
                if (isPremium) {
                    _events.emit(PaywallEvent.PurchaseSuccess)
                }
            }
        }
    }

    fun selectPackage(packageInfo: PackageInfo) {
        _uiState.update { it.copy(selectedPackage = packageInfo) }
    }

    fun onPurchaseClick() {
        val selectedPackage = _uiState.value.selectedPackage ?: return
        _uiState.update { it.copy(isPurchasing = true) }

        viewModelScope.launch {
            when (val result = purchaseManager.purchase(selectedPackage.identifier)) {
                is PurchaseResult.Success -> {
                    _uiState.update { it.copy(isPurchasing = false) }
                    _events.emit(PaywallEvent.PurchaseSuccess)
                }
                is PurchaseResult.Cancelled -> {
                    _uiState.update { it.copy(isPurchasing = false) }
                }
                is PurchaseResult.Error -> {
                    _uiState.update { it.copy(isPurchasing = false, error = result.message) }
                }
            }
        }
    }

    fun onRestoreClick() {
        _uiState.update { it.copy(isRestoring = true) }

        viewModelScope.launch {
            when (val result = purchaseManager.restorePurchases()) {
                is RestoreResult.Success -> {
                    _uiState.update { it.copy(isRestoring = false) }
                    if (result.entitlements.contains("premium")) {
                        _events.emit(PaywallEvent.RestoreSuccess)
                    } else {
                        _events.emit(PaywallEvent.NoPurchasesToRestore)
                    }
                }
                is RestoreResult.Error -> {
                    _uiState.update { it.copy(isRestoring = false, error = result.message) }
                }
            }
        }
    }

    fun clearError() {
        _uiState.update { it.copy(error = null) }
    }
}

data class PaywallUiState(
    val isLoading: Boolean = true,
    val isPurchasing: Boolean = false,
    val isRestoring: Boolean = false,
    val packages: List<PackageInfo> = emptyList(),
    val selectedPackage: PackageInfo? = null,
    val error: String? = null
)

sealed class PaywallEvent {
    object PurchaseSuccess : PaywallEvent()
    object RestoreSuccess : PaywallEvent()
    object NoPurchasesToRestore : PaywallEvent()
}
```

## Android Paywall Screen

### presentation/paywall/PaywallScreen.kt
```kotlin
@Composable
fun PaywallScreen(
    viewModel: PaywallViewModel = koinViewModel(),
    onDismiss: () -> Unit,
    onSuccess: () -> Unit
) {
    val uiState by viewModel.uiState.collectAsState()
    val context = LocalContext.current

    LaunchedEffect(Unit) {
        viewModel.events.collect { event ->
            when (event) {
                PaywallEvent.PurchaseSuccess, PaywallEvent.RestoreSuccess -> onSuccess()
                PaywallEvent.NoPurchasesToRestore -> {
                    Toast.makeText(context, "No purchases to restore", Toast.LENGTH_SHORT).show()
                }
            }
        }
    }

    Scaffold(
        topBar = {
            TopAppBar(
                title = { Text("Upgrade to Premium") },
                navigationIcon = {
                    IconButton(onClick = onDismiss) {
                        Icon(Icons.Default.Close, "Close")
                    }
                }
            )
        }
    ) { padding ->
        Column(
            modifier = Modifier
                .fillMaxSize()
                .padding(padding)
                .verticalScroll(rememberScrollState())
                .padding(16.dp),
            horizontalAlignment = Alignment.CenterHorizontally
        ) {
            // Header
            Icon(
                imageVector = Icons.Default.Star,
                contentDescription = null,
                modifier = Modifier.size(64.dp),
                tint = MaterialTheme.colorScheme.primary
            )

            Spacer(Modifier.height(16.dp))

            Text(
                text = "Unlock All Features",
                style = MaterialTheme.typography.headlineMedium,
                fontWeight = FontWeight.Bold
            )

            Spacer(Modifier.height(24.dp))

            // Features list
            PremiumFeaturesList()

            Spacer(Modifier.height(32.dp))

            // Package selection
            if (uiState.isLoading) {
                CircularProgressIndicator()
            } else {
                PackageSelection(
                    packages = uiState.packages,
                    selectedPackage = uiState.selectedPackage,
                    onSelect = { viewModel.selectPackage(it) }
                )
            }

            Spacer(Modifier.height(24.dp))

            // Purchase button
            Button(
                onClick = { viewModel.onPurchaseClick() },
                enabled = !uiState.isPurchasing && !uiState.isLoading && uiState.selectedPackage != null,
                modifier = Modifier.fillMaxWidth()
            ) {
                if (uiState.isPurchasing) {
                    CircularProgressIndicator(
                        modifier = Modifier.size(20.dp),
                        color = MaterialTheme.colorScheme.onPrimary
                    )
                } else {
                    Text("Subscribe Now")
                }
            }

            Spacer(Modifier.height(8.dp))

            // Restore button
            TextButton(
                onClick = { viewModel.onRestoreClick() },
                enabled = !uiState.isRestoring
            ) {
                if (uiState.isRestoring) {
                    CircularProgressIndicator(modifier = Modifier.size(16.dp))
                } else {
                    Text("Restore Purchases")
                }
            }

            Spacer(Modifier.height(16.dp))

            // Legal links
            Row(
                horizontalArrangement = Arrangement.spacedBy(16.dp)
            ) {
                TextButton(onClick = { /* Open terms */ }) {
                    Text("Terms of Service", style = MaterialTheme.typography.bodySmall)
                }
                TextButton(onClick = { /* Open privacy */ }) {
                    Text("Privacy Policy", style = MaterialTheme.typography.bodySmall)
                }
            }

            // Error display
            uiState.error?.let { error ->
                Spacer(Modifier.height(16.dp))
                Text(
                    text = error,
                    color = MaterialTheme.colorScheme.error,
                    style = MaterialTheme.typography.bodySmall
                )
            }
        }
    }
}

@Composable
fun PremiumFeaturesList() {
    val features = listOf(
        "Unlimited reminders" to Icons.Default.AllInclusive,
        "Cloud sync across devices" to Icons.Default.Cloud,
        "Unlimited labels" to Icons.Default.Label,
        "Priority support" to Icons.Default.SupportAgent
    )

    Column(
        verticalArrangement = Arrangement.spacedBy(12.dp)
    ) {
        features.forEach { (text, icon) ->
            Row(
                verticalAlignment = Alignment.CenterVertically,
                horizontalArrangement = Arrangement.spacedBy(12.dp)
            ) {
                Icon(
                    imageVector = icon,
                    contentDescription = null,
                    tint = MaterialTheme.colorScheme.primary
                )
                Text(text)
            }
        }
    }
}

@Composable
fun PackageSelection(
    packages: List<PackageInfo>,
    selectedPackage: PackageInfo?,
    onSelect: (PackageInfo) -> Unit
) {
    Column(
        verticalArrangement = Arrangement.spacedBy(12.dp),
        modifier = Modifier.fillMaxWidth()
    ) {
        packages.forEach { pkg ->
            PackageCard(
                packageInfo = pkg,
                isSelected = pkg.identifier == selectedPackage?.identifier,
                onSelect = { onSelect(pkg) }
            )
        }
    }
}

@Composable
fun PackageCard(
    packageInfo: PackageInfo,
    isSelected: Boolean,
    onSelect: () -> Unit
) {
    val borderColor = if (isSelected) {
        MaterialTheme.colorScheme.primary
    } else {
        MaterialTheme.colorScheme.outline
    }

    Card(
        modifier = Modifier
            .fillMaxWidth()
            .clickable(onClick = onSelect),
        border = BorderStroke(2.dp, borderColor)
    ) {
        Row(
            modifier = Modifier
                .padding(16.dp)
                .fillMaxWidth(),
            horizontalArrangement = Arrangement.SpaceBetween,
            verticalAlignment = Alignment.CenterVertically
        ) {
            Column {
                Text(
                    text = when (packageInfo.packageType) {
                        PackageType.MONTHLY -> "Monthly"
                        PackageType.ANNUAL -> "Annual (Best Value)"
                        else -> packageInfo.identifier
                    },
                    style = MaterialTheme.typography.titleMedium,
                    fontWeight = FontWeight.Bold
                )

                packageInfo.localizedPricePerMonth?.let { monthly ->
                    Text(
                        text = monthly,
                        style = MaterialTheme.typography.bodySmall,
                        color = MaterialTheme.colorScheme.outline
                    )
                }
            }

            Column(horizontalAlignment = Alignment.End) {
                Text(
                    text = packageInfo.localizedPrice,
                    style = MaterialTheme.typography.titleLarge,
                    fontWeight = FontWeight.Bold
                )

                if (packageInfo.packageType == PackageType.ANNUAL) {
                    Text(
                        text = "Save 33%",
                        style = MaterialTheme.typography.labelSmall,
                        color = MaterialTheme.colorScheme.primary
                    )
                }
            }
        }
    }
}
```

## iOS Paywall Screen

### iosApp/Screens/Paywall/PaywallScreen.swift
```swift
import SwiftUI
import RevenueCat
import RevenueCatUI

struct PaywallScreen: View {
    @EnvironmentObject var purchaseManager: IOSPurchaseManager
    @Environment(\.dismiss) var dismiss

    @State private var selectedPackage: Package?
    @State private var isPurchasing = false
    @State private var isRestoring = false
    @State private var errorMessage: String?
    @State private var showError = false

    var body: some View {
        NavigationStack {
            ScrollView {
                VStack(spacing: 24) {
                    // Header
                    headerSection

                    // Features
                    featuresSection

                    // Packages
                    packagesSection

                    // Purchase button
                    purchaseButton

                    // Restore
                    restoreButton

                    // Legal
                    legalSection
                }
                .padding()
            }
            .navigationTitle("Upgrade to Premium")
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .cancellationAction) {
                    Button("Close") { dismiss() }
                }
            }
            .alert("Error", isPresented: $showError) {
                Button("OK") { }
            } message: {
                Text(errorMessage ?? "An error occurred")
            }
            .task {
                await purchaseManager.fetchOfferings()
                if let defaultOffering = purchaseManager.offerings.first {
                    selectedPackage = defaultOffering.availablePackages.first {
                        $0.packageType == .annual
                    } ?? defaultOffering.availablePackages.first
                }
            }
        }
    }

    private var headerSection: some View {
        VStack(spacing: 16) {
            Image(systemName: "star.fill")
                .font(.system(size: 60))
                .foregroundColor(.yellow)

            Text("Unlock All Features")
                .font(.title)
                .fontWeight(.bold)
        }
    }

    private var featuresSection: some View {
        VStack(alignment: .leading, spacing: 12) {
            FeatureRow(icon: "infinity", text: "Unlimited reminders")
            FeatureRow(icon: "cloud.fill", text: "Cloud sync across devices")
            FeatureRow(icon: "tag.fill", text: "Unlimited labels")
            FeatureRow(icon: "person.fill.questionmark", text: "Priority support")
        }
        .frame(maxWidth: .infinity, alignment: .leading)
    }

    private var packagesSection: some View {
        VStack(spacing: 12) {
            if purchaseManager.isLoading {
                ProgressView()
            } else {
                ForEach(purchaseManager.offerings.first?.availablePackages ?? [], id: \.identifier) { package in
                    PackageCard(
                        package: package,
                        isSelected: selectedPackage?.identifier == package.identifier,
                        onSelect: { selectedPackage = package }
                    )
                }
            }
        }
    }

    private var purchaseButton: some View {
        Button {
            purchase()
        } label: {
            Group {
                if isPurchasing {
                    ProgressView()
                        .tint(.white)
                } else {
                    Text("Subscribe Now")
                }
            }
            .frame(maxWidth: .infinity)
        }
        .buttonStyle(.borderedProminent)
        .controlSize(.large)
        .disabled(isPurchasing || selectedPackage == nil)
    }

    private var restoreButton: some View {
        Button {
            restore()
        } label: {
            if isRestoring {
                ProgressView()
            } else {
                Text("Restore Purchases")
            }
        }
        .disabled(isRestoring)
    }

    private var legalSection: some View {
        HStack(spacing: 16) {
            Button("Terms of Service") { /* Open URL */ }
                .font(.caption)
            Button("Privacy Policy") { /* Open URL */ }
                .font(.caption)
        }
    }

    private func purchase() {
        guard let package = selectedPackage else { return }

        isPurchasing = true

        Task {
            let result = await purchaseManager.purchase(package: package)

            await MainActor.run {
                isPurchasing = false

                switch result {
                case .success:
                    dismiss()
                case .cancelled:
                    break
                case .error(let message):
                    errorMessage = message
                    showError = true
                }
            }
        }
    }

    private func restore() {
        isRestoring = true

        Task {
            let result = await purchaseManager.restorePurchases()

            await MainActor.run {
                isRestoring = false

                switch result {
                case .success(let entitlements):
                    if entitlements.contains("premium") {
                        dismiss()
                    } else {
                        errorMessage = "No purchases to restore"
                        showError = true
                    }
                case .error(let message):
                    errorMessage = message
                    showError = true
                }
            }
        }
    }
}

struct FeatureRow: View {
    let icon: String
    let text: String

    var body: some View {
        HStack(spacing: 12) {
            Image(systemName: icon)
                .foregroundColor(.blue)
                .frame(width: 24)
            Text(text)
        }
    }
}

struct PackageCard: View {
    let package: Package
    let isSelected: Bool
    let onSelect: () -> Void

    var body: some View {
        Button(action: onSelect) {
            HStack {
                VStack(alignment: .leading) {
                    Text(packageTitle)
                        .font(.headline)

                    if let monthly = monthlyPrice {
                        Text(monthly)
                            .font(.caption)
                            .foregroundColor(.secondary)
                    }
                }

                Spacer()

                VStack(alignment: .trailing) {
                    Text(package.localizedPriceString)
                        .font(.title2)
                        .fontWeight(.bold)

                    if package.packageType == .annual {
                        Text("Save 33%")
                            .font(.caption)
                            .foregroundColor(.green)
                    }
                }
            }
            .padding()
            .background(
                RoundedRectangle(cornerRadius: 12)
                    .stroke(isSelected ? Color.blue : Color.gray.opacity(0.3), lineWidth: 2)
            )
        }
        .buttonStyle(.plain)
    }

    private var packageTitle: String {
        switch package.packageType {
        case .monthly: return "Monthly"
        case .annual: return "Annual (Best Value)"
        default: return package.identifier
        }
    }

    private var monthlyPrice: String? {
        guard package.packageType == .annual else { return nil }
        let monthlyAmount = package.storeProduct.price / 12
        return "\(monthlyAmount.formatted(.currency(code: package.storeProduct.currencyCode ?? "USD")))/mo"
    }
}
```

## Trigger Points

### PremiumTrigger Enum
```kotlin
enum class PremiumTrigger {
    REMINDER_LIMIT,      // When user hits free reminder limit
    SYNC_REQUIRED,       // When trying to enable sync
    LABEL_LIMIT,         // When creating more than free label limit
    SETTINGS_UPGRADE,    // From settings screen
    FEATURE_LOCKED       // Generic locked feature
}
```

### Usage in Home ViewModel
```kotlin
class HomeViewModel(
    private val purchaseManager: PurchaseManager,
    // ...
) : ViewModel() {

    private val _showPaywall = MutableSharedFlow<PremiumTrigger>()
    val showPaywall = _showPaywall.asSharedFlow()

    fun onAddReminder() {
        viewModelScope.launch {
            val reminderCount = getRemindersUseCase().first().size

            if (!purchaseManager.isPremium.value && reminderCount >= FREE_REMINDER_LIMIT) {
                _showPaywall.emit(PremiumTrigger.REMINDER_LIMIT)
            } else {
                _navigateToAdd.emit(Unit)
            }
        }
    }

    companion object {
        const val FREE_REMINDER_LIMIT = 10
    }
}
```

## Verification

```kotlin
// Test paywall display and purchase flow

@Test
fun `paywall shows when reminder limit reached`() = runTest {
    // Setup: create 10 reminders (free limit)
    repeat(10) { createReminderUseCase("Reminder $it") }

    // Trigger add
    homeViewModel.onAddReminder()

    // Verify paywall triggered
    assertTrue(homeViewModel.showPaywall.first() == PremiumTrigger.REMINDER_LIMIT)
}

@Test
fun `premium users bypass limit`() = runTest {
    // Setup: premium user with 10 reminders
    purchaseManager.setPremium(true)
    repeat(10) { createReminderUseCase("Reminder $it") }

    // Trigger add
    homeViewModel.onAddReminder()

    // Verify navigation to add screen (not paywall)
    assertNotNull(homeViewModel.navigateToAdd.first())
}
```

```bash
# Manual verification:
# 1. Create 10 reminders as free user
# 2. Try to add 11th - paywall should appear
# 3. Purchase subscription
# 4. Verify can now add unlimited reminders
# 5. Test restore purchases on new device/install
```

## Files to Create/Modify
- `composeApp/src/commonMain/kotlin/.../presentation/paywall/PaywallViewModel.kt`
- `composeApp/src/androidMain/kotlin/.../presentation/paywall/PaywallScreen.kt`
- `iosApp/iosApp/Screens/Paywall/PaywallScreen.swift`
- `composeApp/src/commonMain/kotlin/.../domain/purchase/PremiumTrigger.kt`
- Update `HomeViewModel.kt` with paywall triggers
- Update navigation to include paywall route
- Add paywall to Settings screen
