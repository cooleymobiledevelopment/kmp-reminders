# F1.5: Use Cases - Reminder Logic

## Objective
Create use cases for reminder-specific logic: snooze, complete, and recurrence handling.

## Dependencies
- F1.1 (ReminderRepository)
- F1.2 (RecurrenceRule)
- F1.4 (Basic use cases)

## Requirements
- [ ] `SnoozeReminderUseCase` - snooze for specific duration
- [ ] `CompleteReminderUseCase` - mark complete, handle recurrence
- [ ] `DismissReminderUseCase` - dismiss without completing
- [ ] `CalculateNextOccurrenceUseCase` - wrapper for RecurrenceCalculator
- [ ] State machine logic: pending → triggered → snoozed/completed
- [ ] Unit tests

## Use Cases

### domain/usecase/SnoozeReminderUseCase.kt
```kotlin
package com.cooleymd.reminders.domain.usecase

import kotlin.time.Duration

class SnoozeReminderUseCase(
    private val reminderRepository: ReminderRepository
) {
    suspend operator fun invoke(
        reminderId: String,
        duration: Duration
    ): Reminder {
        val reminder = reminderRepository.getReminderById(reminderId)
            ?: throw IllegalArgumentException("Reminder not found")

        val snoozedUntil = Clock.System.now() + duration
        val updated = reminder.copy(
            status = ReminderStatus.SNOOZED,
            snoozedUntil = snoozedUntil,
            updatedAt = Clock.System.now()
        )

        reminderRepository.updateReminder(updated)
        return updated
    }
}
```

### domain/usecase/CompleteReminderUseCase.kt
```kotlin
class CompleteReminderUseCase(
    private val reminderRepository: ReminderRepository,
    private val recurrenceCalculator: RecurrenceCalculator
) {
    suspend operator fun invoke(reminderId: String): CompleteResult {
        val reminder = reminderRepository.getReminderById(reminderId)
            ?: throw IllegalArgumentException("Reminder not found")

        val now = Clock.System.now()

        // Mark current as completed
        val completed = reminder.copy(
            status = ReminderStatus.COMPLETED,
            completedAt = now,
            updatedAt = now
        )
        reminderRepository.updateReminder(completed)

        // If recurring, create next occurrence
        if (reminder.recurrenceRule != null) {
            val nextOccurrence = recurrenceCalculator.calculateNextOccurrence(
                rule = reminder.recurrenceRule,
                after = now
            )

            if (nextOccurrence != null) {
                val nextReminder = reminder.copy(
                    id = UUID.randomUUID().toString(),
                    scheduledAt = nextOccurrence,
                    status = ReminderStatus.PENDING,
                    snoozedUntil = null,
                    completedAt = null,
                    createdAt = now,
                    updatedAt = now
                )
                reminderRepository.insertReminder(nextReminder)
                return CompleteResult.CompletedWithNext(completed, nextReminder)
            }
        }

        return CompleteResult.Completed(completed)
    }
}

sealed class CompleteResult {
    data class Completed(val reminder: Reminder) : CompleteResult()
    data class CompletedWithNext(
        val completed: Reminder,
        val nextOccurrence: Reminder
    ) : CompleteResult()
}
```

### domain/usecase/DismissReminderUseCase.kt
```kotlin
class DismissReminderUseCase(
    private val reminderRepository: ReminderRepository
) {
    suspend operator fun invoke(reminderId: String) {
        val reminder = reminderRepository.getReminderById(reminderId)
            ?: throw IllegalArgumentException("Reminder not found")

        val dismissed = reminder.copy(
            status = ReminderStatus.DISMISSED,
            updatedAt = Clock.System.now()
        )
        reminderRepository.updateReminder(dismissed)
    }
}
```

## State Machine

```
PENDING ──────────► TRIGGERED ──────────► COMPLETED
    │                   │                      ▲
    │                   │                      │
    │                   ▼                      │
    │               SNOOZED ───────────────────┤
    │                   │                      │
    │                   └──────► PENDING ──────┘
    │
    └────────────────────────────────────► DISMISSED
```

Transitions:
- PENDING → TRIGGERED: When scheduled time is reached
- TRIGGERED → SNOOZED: User snoozes
- SNOOZED → PENDING: Snooze time expires
- TRIGGERED → COMPLETED: User completes
- TRIGGERED → DISMISSED: User dismisses
- PENDING → DISMISSED: User deletes before trigger

## Koin Registration

Add to AppModule.kt:
```kotlin
factory { SnoozeReminderUseCase(get()) }
factory { CompleteReminderUseCase(get(), get()) }
factory { DismissReminderUseCase(get()) }
single { RecurrenceCalculator() }
```

## Tests

- Test snooze updates status and snoozedUntil
- Test complete marks as completed
- Test complete with recurrence creates next occurrence
- Test complete with ended recurrence doesn't create next
- Test dismiss updates status

## Verification
```bash
./gradlew build
./gradlew :composeApp:testDebugUnitTest --tests "*SnoozeReminder*"
./gradlew :composeApp:testDebugUnitTest --tests "*CompleteReminder*"
```

## Files to Create
- `composeApp/src/commonMain/kotlin/.../domain/usecase/SnoozeReminderUseCase.kt`
- `composeApp/src/commonMain/kotlin/.../domain/usecase/CompleteReminderUseCase.kt`
- `composeApp/src/commonMain/kotlin/.../domain/usecase/DismissReminderUseCase.kt`
- `composeApp/src/commonTest/kotlin/.../SnoozeReminderUseCaseTest.kt`
- `composeApp/src/commonTest/kotlin/.../CompleteReminderUseCaseTest.kt`
- Update `di/AppModule.kt`
