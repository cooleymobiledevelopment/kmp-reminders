# F5.2: Backend Authentication - JWT Endpoints

## Objective
Implement register, login, and token refresh endpoints with JWT authentication.

## Dependencies
- F5.1 (Backend setup with database)

## Requirements
- [ ] User registration endpoint (email, password)
- [ ] Login endpoint returning JWT access and refresh tokens
- [ ] Token refresh endpoint
- [ ] Password hashing with BCrypt
- [ ] JWT validation middleware
- [ ] Protected route example
- [ ] Logout/token revocation (optional)

## Authentication DTOs

### domain/models/AuthModels.kt
```kotlin
package com.cooleymd.reminders.domain.models

import kotlinx.serialization.Serializable

@Serializable
data class RegisterRequest(
    val email: String,
    val password: String,
    val displayName: String? = null
)

@Serializable
data class LoginRequest(
    val email: String,
    val password: String
)

@Serializable
data class RefreshRequest(
    val refreshToken: String
)

@Serializable
data class AuthResponse(
    val accessToken: String,
    val refreshToken: String,
    val expiresIn: Long, // seconds
    val user: UserResponse
)

@Serializable
data class UserResponse(
    val id: String,
    val email: String,
    val displayName: String?
)

@Serializable
data class ErrorResponse(
    val error: String,
    val message: String
)
```

## User Repository

### data/repositories/UserRepository.kt
```kotlin
package com.cooleymd.reminders.data.repositories

import com.cooleymd.reminders.data.tables.UsersTable
import com.cooleymd.reminders.domain.models.UserResponse
import kotlinx.datetime.Clock
import org.jetbrains.exposed.sql.*
import org.jetbrains.exposed.sql.SqlExpressionBuilder.eq
import org.jetbrains.exposed.sql.transactions.transaction
import org.mindrot.jbcrypt.BCrypt
import java.util.*

class UserRepository {

    fun createUser(email: String, password: String, displayName: String?): UserResponse? {
        val passwordHash = BCrypt.hashpw(password, BCrypt.gensalt())
        val now = Clock.System.now()
        val userId = UUID.randomUUID()

        return transaction {
            // Check if user already exists
            val existing = UsersTable.select { UsersTable.email eq email }.firstOrNull()
            if (existing != null) {
                return@transaction null
            }

            UsersTable.insert {
                it[id] = userId
                it[UsersTable.email] = email
                it[UsersTable.passwordHash] = passwordHash
                it[UsersTable.displayName] = displayName
                it[createdAt] = now
                it[updatedAt] = now
            }

            UserResponse(
                id = userId.toString(),
                email = email,
                displayName = displayName
            )
        }
    }

    fun findByEmail(email: String): UserWithPassword? {
        return transaction {
            UsersTable.select { UsersTable.email eq email }
                .firstOrNull()
                ?.let {
                    UserWithPassword(
                        id = it[UsersTable.id].toString(),
                        email = it[UsersTable.email],
                        passwordHash = it[UsersTable.passwordHash],
                        displayName = it[UsersTable.displayName]
                    )
                }
        }
    }

    fun findById(userId: String): UserResponse? {
        return transaction {
            UsersTable.select { UsersTable.id eq UUID.fromString(userId) }
                .firstOrNull()
                ?.let {
                    UserResponse(
                        id = it[UsersTable.id].toString(),
                        email = it[UsersTable.email],
                        displayName = it[UsersTable.displayName]
                    )
                }
        }
    }

    fun verifyPassword(plainPassword: String, hashedPassword: String): Boolean {
        return BCrypt.checkpw(plainPassword, hashedPassword)
    }
}

data class UserWithPassword(
    val id: String,
    val email: String,
    val passwordHash: String,
    val displayName: String?
)
```

## JWT Service

### domain/services/JwtService.kt
```kotlin
package com.cooleymd.reminders.domain.services

import com.auth0.jwt.JWT
import com.auth0.jwt.algorithms.Algorithm
import com.auth0.jwt.exceptions.JWTVerificationException
import io.ktor.server.application.*
import java.util.*

class JwtService(private val environment: ApplicationEnvironment) {

    private val secret = environment.config.property("jwt.secret").getString()
    private val issuer = environment.config.property("jwt.issuer").getString()
    private val audience = environment.config.property("jwt.audience").getString()
    private val expirationMinutes = environment.config
        .propertyOrNull("jwt.expirationMinutes")?.getString()?.toLong() ?: 60
    private val refreshExpirationDays = environment.config
        .propertyOrNull("jwt.refreshExpirationDays")?.getString()?.toLong() ?: 30

    private val algorithm = Algorithm.HMAC256(secret)

    val verifier = JWT.require(algorithm)
        .withIssuer(issuer)
        .withAudience(audience)
        .build()

    fun generateAccessToken(userId: String, email: String): String {
        return JWT.create()
            .withIssuer(issuer)
            .withAudience(audience)
            .withSubject(userId)
            .withClaim("email", email)
            .withClaim("type", "access")
            .withExpiresAt(Date(System.currentTimeMillis() + expirationMinutes * 60 * 1000))
            .sign(algorithm)
    }

    fun generateRefreshToken(userId: String): String {
        return JWT.create()
            .withIssuer(issuer)
            .withAudience(audience)
            .withSubject(userId)
            .withClaim("type", "refresh")
            .withExpiresAt(Date(System.currentTimeMillis() + refreshExpirationDays * 24 * 60 * 60 * 1000))
            .sign(algorithm)
    }

    fun verifyRefreshToken(token: String): String? {
        return try {
            val decoded = verifier.verify(token)
            if (decoded.getClaim("type").asString() == "refresh") {
                decoded.subject
            } else {
                null
            }
        } catch (e: JWTVerificationException) {
            null
        }
    }

    fun getExpirationSeconds(): Long = expirationMinutes * 60
}
```

## Security Plugin

### plugins/Security.kt
```kotlin
package com.cooleymd.reminders.plugins

import com.cooleymd.reminders.domain.services.JwtService
import io.ktor.http.*
import io.ktor.server.application.*
import io.ktor.server.auth.*
import io.ktor.server.auth.jwt.*
import io.ktor.server.plugins.cors.routing.*
import io.ktor.server.response.*

fun Application.configureSecurity() {
    val jwtService = JwtService(environment)

    install(CORS) {
        allowMethod(HttpMethod.Options)
        allowMethod(HttpMethod.Get)
        allowMethod(HttpMethod.Post)
        allowMethod(HttpMethod.Put)
        allowMethod(HttpMethod.Delete)
        allowHeader(HttpHeaders.Authorization)
        allowHeader(HttpHeaders.ContentType)
        anyHost() // Configure properly for production
    }

    install(Authentication) {
        jwt("auth-jwt") {
            realm = environment.config.property("jwt.realm").getString()
            verifier(jwtService.verifier)
            validate { credential ->
                val userId = credential.payload.subject
                val tokenType = credential.payload.getClaim("type").asString()

                if (userId != null && tokenType == "access") {
                    JWTPrincipal(credential.payload)
                } else {
                    null
                }
            }
            challenge { _, _ ->
                call.respond(
                    HttpStatusCode.Unauthorized,
                    mapOf("error" to "unauthorized", "message" to "Token is invalid or expired")
                )
            }
        }
    }
}

// Extension to get current user ID from JWT
val ApplicationCall.userId: String?
    get() = principal<JWTPrincipal>()?.subject
```

## Auth Routes

### routes/AuthRoutes.kt
```kotlin
package com.cooleymd.reminders.routes

import com.cooleymd.reminders.data.repositories.UserRepository
import com.cooleymd.reminders.domain.models.*
import com.cooleymd.reminders.domain.services.JwtService
import io.ktor.http.*
import io.ktor.server.application.*
import io.ktor.server.request.*
import io.ktor.server.response.*
import io.ktor.server.routing.*

fun Route.authRoutes(userRepository: UserRepository, jwtService: JwtService) {

    route("/auth") {

        post("/register") {
            val request = call.receive<RegisterRequest>()

            // Validate input
            if (request.email.isBlank() || !request.email.contains("@")) {
                call.respond(
                    HttpStatusCode.BadRequest,
                    ErrorResponse("invalid_email", "Please provide a valid email address")
                )
                return@post
            }

            if (request.password.length < 8) {
                call.respond(
                    HttpStatusCode.BadRequest,
                    ErrorResponse("weak_password", "Password must be at least 8 characters")
                )
                return@post
            }

            val user = userRepository.createUser(
                email = request.email.lowercase().trim(),
                password = request.password,
                displayName = request.displayName
            )

            if (user == null) {
                call.respond(
                    HttpStatusCode.Conflict,
                    ErrorResponse("email_exists", "An account with this email already exists")
                )
                return@post
            }

            val accessToken = jwtService.generateAccessToken(user.id, user.email)
            val refreshToken = jwtService.generateRefreshToken(user.id)

            call.respond(
                HttpStatusCode.Created,
                AuthResponse(
                    accessToken = accessToken,
                    refreshToken = refreshToken,
                    expiresIn = jwtService.getExpirationSeconds(),
                    user = user
                )
            )
        }

        post("/login") {
            val request = call.receive<LoginRequest>()

            val user = userRepository.findByEmail(request.email.lowercase().trim())

            if (user == null || !userRepository.verifyPassword(request.password, user.passwordHash)) {
                call.respond(
                    HttpStatusCode.Unauthorized,
                    ErrorResponse("invalid_credentials", "Invalid email or password")
                )
                return@post
            }

            val accessToken = jwtService.generateAccessToken(user.id, user.email)
            val refreshToken = jwtService.generateRefreshToken(user.id)

            call.respond(
                AuthResponse(
                    accessToken = accessToken,
                    refreshToken = refreshToken,
                    expiresIn = jwtService.getExpirationSeconds(),
                    user = UserResponse(
                        id = user.id,
                        email = user.email,
                        displayName = user.displayName
                    )
                )
            )
        }

        post("/refresh") {
            val request = call.receive<RefreshRequest>()

            val userId = jwtService.verifyRefreshToken(request.refreshToken)

            if (userId == null) {
                call.respond(
                    HttpStatusCode.Unauthorized,
                    ErrorResponse("invalid_token", "Invalid or expired refresh token")
                )
                return@post
            }

            val user = userRepository.findById(userId)

            if (user == null) {
                call.respond(
                    HttpStatusCode.Unauthorized,
                    ErrorResponse("user_not_found", "User no longer exists")
                )
                return@post
            }

            val accessToken = jwtService.generateAccessToken(user.id, user.email)
            val refreshToken = jwtService.generateRefreshToken(user.id)

            call.respond(
                AuthResponse(
                    accessToken = accessToken,
                    refreshToken = refreshToken,
                    expiresIn = jwtService.getExpirationSeconds(),
                    user = user
                )
            )
        }
    }
}
```

## Update Routing Plugin

### plugins/Routing.kt (updated)
```kotlin
package com.cooleymd.reminders.plugins

import com.cooleymd.reminders.data.repositories.UserRepository
import com.cooleymd.reminders.domain.services.JwtService
import com.cooleymd.reminders.routes.authRoutes
import com.cooleymd.reminders.routes.healthRoutes
import io.ktor.server.application.*
import io.ktor.server.auth.*
import io.ktor.server.plugins.callloging.*
import io.ktor.server.plugins.statuspages.*
import io.ktor.server.response.*
import io.ktor.server.routing.*
import io.ktor.http.*
import org.slf4j.event.Level

fun Application.configureRouting() {
    val userRepository = UserRepository()
    val jwtService = JwtService(environment)

    install(CallLogging) {
        level = Level.INFO
    }

    install(StatusPages) {
        exception<Throwable> { call, cause ->
            call.application.log.error("Unhandled exception", cause)
            call.respond(
                HttpStatusCode.InternalServerError,
                mapOf("error" to "internal_error", "message" to (cause.message ?: "Internal server error"))
            )
        }
    }

    routing {
        healthRoutes()
        authRoutes(userRepository, jwtService)

        // Protected routes example
        authenticate("auth-jwt") {
            get("/me") {
                val userId = call.userId
                if (userId == null) {
                    call.respond(HttpStatusCode.Unauthorized)
                    return@get
                }

                val user = userRepository.findById(userId)
                if (user == null) {
                    call.respond(HttpStatusCode.NotFound)
                    return@get
                }

                call.respond(user)
            }
        }
    }
}
```

## Verification

```bash
# Start the server
./gradlew run

# Register a new user
curl -X POST http://localhost:8080/auth/register \
  -H "Content-Type: application/json" \
  -d '{"email": "test@example.com", "password": "password123", "displayName": "Test User"}'

# Login
curl -X POST http://localhost:8080/auth/login \
  -H "Content-Type: application/json" \
  -d '{"email": "test@example.com", "password": "password123"}'

# Use access token to get user info
curl http://localhost:8080/me \
  -H "Authorization: Bearer <access_token>"

# Refresh token
curl -X POST http://localhost:8080/auth/refresh \
  -H "Content-Type: application/json" \
  -d '{"refreshToken": "<refresh_token>"}'

# Test invalid credentials
curl -X POST http://localhost:8080/auth/login \
  -H "Content-Type: application/json" \
  -d '{"email": "test@example.com", "password": "wrongpassword"}'
# Expected: 401 Unauthorized
```

## Files to Create/Modify
- `backend/src/main/kotlin/com/cooleymd/reminders/domain/models/AuthModels.kt`
- `backend/src/main/kotlin/com/cooleymd/reminders/data/repositories/UserRepository.kt`
- `backend/src/main/kotlin/com/cooleymd/reminders/domain/services/JwtService.kt`
- Update `backend/src/main/kotlin/com/cooleymd/reminders/plugins/Security.kt`
- `backend/src/main/kotlin/com/cooleymd/reminders/routes/AuthRoutes.kt`
- Update `backend/src/main/kotlin/com/cooleymd/reminders/plugins/Routing.kt`
