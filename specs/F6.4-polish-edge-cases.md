# F6.4: Polish and Edge Cases

## Objective
Handle error states, loading states, edge cases, and add final polish including app icon.

## Dependencies
- All previous features implemented

## Requirements
- [ ] Consistent error handling across app
- [ ] Loading states for all async operations
- [ ] Empty states for all lists
- [ ] Offline mode handling
- [ ] Network error retry UI
- [ ] Input validation
- [ ] App icon for both platforms
- [ ] Splash screen
- [ ] Accessibility support
- [ ] Analytics events (optional)

## Error Handling Architecture

### domain/error/AppError.kt
```kotlin
package com.cooleymd.reminders.domain.error

sealed class AppError : Exception() {
    // Network errors
    data class NetworkError(
        override val message: String = "Network error. Please check your connection."
    ) : AppError()

    data class ServerError(
        val code: Int,
        override val message: String = "Server error. Please try again later."
    ) : AppError()

    data class Timeout(
        override val message: String = "Request timed out. Please try again."
    ) : AppError()

    // Auth errors
    data class Unauthorized(
        override val message: String = "Please log in to continue."
    ) : AppError()

    data class SessionExpired(
        override val message: String = "Your session has expired. Please log in again."
    ) : AppError()

    // Data errors
    data class NotFound(
        val resourceType: String,
        override val message: String = "$resourceType not found."
    ) : AppError()

    data class ValidationError(
        val field: String,
        override val message: String
    ) : AppError()

    // Generic
    data class Unknown(
        override val message: String = "Something went wrong. Please try again."
    ) : AppError()
}
```

### domain/error/ErrorHandler.kt
```kotlin
package com.cooleymd.reminders.domain.error

import io.ktor.client.plugins.*
import io.ktor.http.*
import kotlinx.coroutines.CancellationException
import java.net.UnknownHostException
import java.net.SocketTimeoutException

object ErrorHandler {
    fun handle(throwable: Throwable): AppError {
        return when (throwable) {
            is AppError -> throwable
            is CancellationException -> throw throwable // Don't catch cancellation
            is UnknownHostException -> AppError.NetworkError()
            is SocketTimeoutException -> AppError.Timeout()
            is ResponseException -> handleHttpError(throwable)
            else -> AppError.Unknown(throwable.message ?: "Unknown error")
        }
    }

    private fun handleHttpError(exception: ResponseException): AppError {
        return when (exception.response.status) {
            HttpStatusCode.Unauthorized -> AppError.Unauthorized()
            HttpStatusCode.NotFound -> AppError.NotFound("Resource")
            HttpStatusCode.InternalServerError -> AppError.ServerError(500)
            else -> AppError.ServerError(exception.response.status.value)
        }
    }
}
```

## Global Error Handler Composable

### presentation/components/ErrorHandler.kt
```kotlin
@Composable
fun ErrorSnackbar(
    error: AppError?,
    onDismiss: () -> Unit,
    onRetry: (() -> Unit)? = null
) {
    val snackbarHostState = remember { SnackbarHostState() }

    LaunchedEffect(error) {
        if (error != null) {
            val result = snackbarHostState.showSnackbar(
                message = error.message,
                actionLabel = if (onRetry != null) "Retry" else "Dismiss",
                duration = SnackbarDuration.Long
            )

            when (result) {
                SnackbarResult.ActionPerformed -> {
                    onRetry?.invoke() ?: onDismiss()
                }
                SnackbarResult.Dismissed -> onDismiss()
            }
        }
    }

    SnackbarHost(hostState = snackbarHostState)
}
```

## Full-Screen Error State

### presentation/components/ErrorScreen.kt
```kotlin
@Composable
fun ErrorScreen(
    error: AppError,
    onRetry: () -> Unit,
    modifier: Modifier = Modifier
) {
    Column(
        modifier = modifier
            .fillMaxSize()
            .padding(32.dp),
        horizontalAlignment = Alignment.CenterHorizontally,
        verticalArrangement = Arrangement.Center
    ) {
        val (icon, title) = when (error) {
            is AppError.NetworkError -> Icons.Default.WifiOff to "No Connection"
            is AppError.ServerError -> Icons.Default.CloudOff to "Server Error"
            is AppError.Timeout -> Icons.Default.Schedule to "Timed Out"
            is AppError.Unauthorized, is AppError.SessionExpired ->
                Icons.Default.Lock to "Authentication Required"
            else -> Icons.Default.Error to "Something Went Wrong"
        }

        Icon(
            imageVector = icon,
            contentDescription = null,
            modifier = Modifier.size(80.dp),
            tint = MaterialTheme.colorScheme.error
        )

        Spacer(Modifier.height(24.dp))

        Text(
            text = title,
            style = MaterialTheme.typography.headlineSmall,
            fontWeight = FontWeight.Bold
        )

        Spacer(Modifier.height(8.dp))

        Text(
            text = error.message,
            style = MaterialTheme.typography.bodyMedium,
            textAlign = TextAlign.Center,
            color = MaterialTheme.colorScheme.onSurfaceVariant
        )

        Spacer(Modifier.height(24.dp))

        Button(onClick = onRetry) {
            Text("Try Again")
        }
    }
}
```

## Loading States

### presentation/components/LoadingIndicators.kt
```kotlin
@Composable
fun FullScreenLoading(
    message: String = "Loading..."
) {
    Box(
        modifier = Modifier.fillMaxSize(),
        contentAlignment = Alignment.Center
    ) {
        Column(
            horizontalAlignment = Alignment.CenterHorizontally
        ) {
            CircularProgressIndicator()
            Spacer(Modifier.height(16.dp))
            Text(
                text = message,
                style = MaterialTheme.typography.bodyMedium,
                color = MaterialTheme.colorScheme.onSurfaceVariant
            )
        }
    }
}

@Composable
fun ShimmerLoadingList(
    itemCount: Int = 5
) {
    LazyColumn {
        items(itemCount) {
            ShimmerItem()
        }
    }
}

@Composable
fun ShimmerItem() {
    val shimmerColors = listOf(
        MaterialTheme.colorScheme.surfaceVariant.copy(alpha = 0.6f),
        MaterialTheme.colorScheme.surfaceVariant.copy(alpha = 0.2f),
        MaterialTheme.colorScheme.surfaceVariant.copy(alpha = 0.6f)
    )

    val transition = rememberInfiniteTransition(label = "shimmer")
    val translateAnim = transition.animateFloat(
        initialValue = 0f,
        targetValue = 1000f,
        animationSpec = infiniteRepeatable(
            animation = tween(1200, easing = FastOutSlowInEasing),
            repeatMode = RepeatMode.Restart
        ),
        label = "shimmerTranslate"
    )

    val brush = Brush.linearGradient(
        colors = shimmerColors,
        start = Offset.Zero,
        end = Offset(translateAnim.value, translateAnim.value)
    )

    Card(
        modifier = Modifier
            .fillMaxWidth()
            .padding(horizontal = 16.dp, vertical = 4.dp)
    ) {
        Column(modifier = Modifier.padding(16.dp)) {
            Box(
                modifier = Modifier
                    .fillMaxWidth(0.7f)
                    .height(20.dp)
                    .background(brush, RoundedCornerShape(4.dp))
            )
            Spacer(Modifier.height(8.dp))
            Box(
                modifier = Modifier
                    .fillMaxWidth(0.5f)
                    .height(14.dp)
                    .background(brush, RoundedCornerShape(4.dp))
            )
        }
    }
}
```

## Empty States

### presentation/components/EmptyStates.kt
```kotlin
@Composable
fun EmptyState(
    icon: ImageVector,
    title: String,
    message: String,
    actionLabel: String? = null,
    onAction: (() -> Unit)? = null,
    modifier: Modifier = Modifier
) {
    Column(
        modifier = modifier
            .fillMaxSize()
            .padding(32.dp),
        horizontalAlignment = Alignment.CenterHorizontally,
        verticalArrangement = Arrangement.Center
    ) {
        Icon(
            imageVector = icon,
            contentDescription = null,
            modifier = Modifier.size(80.dp),
            tint = MaterialTheme.colorScheme.outline
        )

        Spacer(Modifier.height(24.dp))

        Text(
            text = title,
            style = MaterialTheme.typography.headlineSmall,
            fontWeight = FontWeight.Bold
        )

        Spacer(Modifier.height(8.dp))

        Text(
            text = message,
            style = MaterialTheme.typography.bodyMedium,
            textAlign = TextAlign.Center,
            color = MaterialTheme.colorScheme.onSurfaceVariant
        )

        if (actionLabel != null && onAction != null) {
            Spacer(Modifier.height(24.dp))
            Button(onClick = onAction) {
                Text(actionLabel)
            }
        }
    }
}

// Pre-built empty states
@Composable
fun NoRemindersEmpty(onAddClick: () -> Unit) {
    EmptyState(
        icon = Icons.Default.NotificationsNone,
        title = "No Reminders",
        message = "You don't have any reminders yet. Create one to get started!",
        actionLabel = "Add Reminder",
        onAction = onAddClick
    )
}

@Composable
fun NoLabelsEmpty(onAddClick: () -> Unit) {
    EmptyState(
        icon = Icons.Default.Label,
        title = "No Labels",
        message = "Create labels to organize your reminders.",
        actionLabel = "Add Label",
        onAction = onAddClick
    )
}

@Composable
fun NoSearchResultsEmpty() {
    EmptyState(
        icon = Icons.Default.SearchOff,
        title = "No Results",
        message = "No reminders match your search. Try different keywords."
    )
}
```

## Offline Mode Banner

### presentation/components/OfflineBanner.kt
```kotlin
@Composable
fun OfflineBanner(
    isOffline: Boolean,
    modifier: Modifier = Modifier
) {
    AnimatedVisibility(
        visible = isOffline,
        enter = slideInVertically() + fadeIn(),
        exit = slideOutVertically() + fadeOut()
    ) {
        Surface(
            color = MaterialTheme.colorScheme.errorContainer,
            modifier = modifier.fillMaxWidth()
        ) {
            Row(
                modifier = Modifier.padding(12.dp),
                verticalAlignment = Alignment.CenterVertically,
                horizontalArrangement = Arrangement.Center
            ) {
                Icon(
                    imageVector = Icons.Default.WifiOff,
                    contentDescription = null,
                    modifier = Modifier.size(16.dp),
                    tint = MaterialTheme.colorScheme.onErrorContainer
                )
                Spacer(Modifier.width(8.dp))
                Text(
                    text = "You're offline. Changes will sync when connected.",
                    style = MaterialTheme.typography.bodySmall,
                    color = MaterialTheme.colorScheme.onErrorContainer
                )
            }
        }
    }
}
```

## Input Validation

### domain/validation/Validators.kt
```kotlin
package com.cooleymd.reminders.domain.validation

object Validators {
    fun validateReminderTitle(title: String): ValidationResult {
        return when {
            title.isBlank() -> ValidationResult.Error("Title is required")
            title.length > 500 -> ValidationResult.Error("Title is too long (max 500 characters)")
            else -> ValidationResult.Valid
        }
    }

    fun validateEmail(email: String): ValidationResult {
        val emailRegex = "^[A-Za-z0-9+_.-]+@[A-Za-z0-9.-]+\$".toRegex()
        return when {
            email.isBlank() -> ValidationResult.Error("Email is required")
            !email.matches(emailRegex) -> ValidationResult.Error("Invalid email format")
            else -> ValidationResult.Valid
        }
    }

    fun validatePassword(password: String): ValidationResult {
        return when {
            password.length < 8 -> ValidationResult.Error("Password must be at least 8 characters")
            !password.any { it.isDigit() } -> ValidationResult.Error("Password must contain a number")
            !password.any { it.isUpperCase() } -> ValidationResult.Error("Password must contain an uppercase letter")
            else -> ValidationResult.Valid
        }
    }

    fun validateLabelName(name: String): ValidationResult {
        return when {
            name.isBlank() -> ValidationResult.Error("Label name is required")
            name.length > 50 -> ValidationResult.Error("Label name is too long")
            else -> ValidationResult.Valid
        }
    }

    fun validateFutureDate(date: Instant): ValidationResult {
        return if (date > Clock.System.now()) {
            ValidationResult.Valid
        } else {
            ValidationResult.Error("Date must be in the future")
        }
    }
}

sealed class ValidationResult {
    object Valid : ValidationResult()
    data class Error(val message: String) : ValidationResult()
}
```

## Splash Screen

### Android - res/values/themes.xml
```xml
<style name="Theme.Reminders.Splash" parent="Theme.SplashScreen">
    <item name="windowSplashScreenBackground">@color/primary</item>
    <item name="windowSplashScreenAnimatedIcon">@drawable/ic_splash</item>
    <item name="windowSplashScreenAnimationDuration">300</item>
    <item name="postSplashScreenTheme">@style/Theme.Reminders</item>
</style>
```

### Android - MainActivity.kt
```kotlin
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        val splashScreen = installSplashScreen()

        super.onCreate(savedInstanceState)

        // Keep splash screen while loading initial data
        var keepSplash = true
        splashScreen.setKeepOnScreenCondition { keepSplash }

        setContent {
            val isReady by rememberUpdatedState(/* initial data loaded */)

            LaunchedEffect(isReady) {
                if (isReady) keepSplash = false
            }

            RemindersTheme {
                AppNavigation()
            }
        }
    }
}
```

### iOS - Launch Screen
Create `LaunchScreen.storyboard` with app icon and loading indicator.

## App Icons

### Android Icon Specification
Create icons in these sizes:
- `mipmap-mdpi/ic_launcher.png` - 48x48
- `mipmap-hdpi/ic_launcher.png` - 72x72
- `mipmap-xhdpi/ic_launcher.png` - 96x96
- `mipmap-xxhdpi/ic_launcher.png` - 144x144
- `mipmap-xxxhdpi/ic_launcher.png` - 192x192

Also create adaptive icons:
- `mipmap-anydpi-v26/ic_launcher.xml`
- `drawable/ic_launcher_foreground.xml`
- `drawable/ic_launcher_background.xml`

### iOS Icon Specification
Add to `Assets.xcassets/AppIcon.appiconset`:
- 1024x1024 (App Store)
- Various sizes for different devices

## Accessibility

### presentation/accessibility/AccessibilityUtils.kt
```kotlin
fun Modifier.semanticsForReminder(reminder: Reminder): Modifier {
    return this.semantics {
        contentDescription = buildString {
            append(reminder.title)
            append(". ")
            if (reminder.status == ReminderStatus.COMPLETED) {
                append("Completed. ")
            } else {
                append("Scheduled for ${reminder.scheduledAt.formatForSpeech()}. ")
            }
            reminder.notes?.let { append(it) }
        }
    }
}

fun Instant.formatForSpeech(): String {
    // Format date/time for screen reader
    val date = this.toLocalDateTime(TimeZone.currentSystemDefault())
    return "${date.month.name} ${date.dayOfMonth} at ${date.hour}:${date.minute.toString().padStart(2, '0')}"
}
```

### Update ReminderCard with accessibility
```kotlin
@Composable
fun ReminderCard(
    reminder: Reminder,
    onClick: () -> Unit
) {
    Card(
        modifier = Modifier
            .fillMaxWidth()
            .padding(horizontal = 16.dp, vertical = 4.dp)
            .clickable(onClick = onClick)
            .semanticsForReminder(reminder)
    ) {
        // ... content
    }
}
```

## Analytics Events (Optional)

### domain/analytics/AnalyticsEvent.kt
```kotlin
sealed class AnalyticsEvent(val name: String, val params: Map<String, Any> = emptyMap()) {
    object AppOpened : AnalyticsEvent("app_opened")
    data class ReminderCreated(val hasRecurrence: Boolean) : AnalyticsEvent(
        "reminder_created",
        mapOf("has_recurrence" to hasRecurrence)
    )
    data class ReminderCompleted(val wasOverdue: Boolean) : AnalyticsEvent(
        "reminder_completed",
        mapOf("was_overdue" to wasOverdue)
    )
    object PaywallViewed : AnalyticsEvent("paywall_viewed")
    data class PurchaseCompleted(val productId: String) : AnalyticsEvent(
        "purchase_completed",
        mapOf("product_id" to productId)
    )
    object SyncStarted : AnalyticsEvent("sync_started")
    data class SyncCompleted(val itemCount: Int) : AnalyticsEvent(
        "sync_completed",
        mapOf("item_count" to itemCount)
    )
}
```

## Verification

```kotlin
// Test error handling
@Test
fun `network error shows retry option`() = runTest {
    // Mock network failure
    coEvery { api.getReminders() } throws UnknownHostException()

    viewModel.loadReminders()

    // Verify error state
    val state = viewModel.uiState.value
    assertTrue(state.error is AppError.NetworkError)
}

// Test loading states
@Test
fun `loading state shown during fetch`() = runTest {
    val deferred = CompletableDeferred<List<Reminder>>()
    coEvery { api.getReminders() } coAnswers { deferred.await() }

    viewModel.loadReminders()

    // Verify loading
    assertTrue(viewModel.uiState.value.isLoading)

    deferred.complete(emptyList())

    // Verify loaded
    assertFalse(viewModel.uiState.value.isLoading)
}

// Test offline mode
@Test
fun `offline banner shown when disconnected`() = runTest {
    connectivityMonitor.setConnected(false)

    // Verify offline state propagates to UI
    assertTrue(viewModel.isOffline.value)
}
```

```bash
# Manual verification checklist:
# [ ] Error snackbars appear on API failures
# [ ] Full-screen error for critical failures
# [ ] Loading shimmer on initial load
# [ ] Empty states for all list screens
# [ ] Offline banner appears when disconnected
# [ ] Changes queue while offline
# [ ] Retry buttons work
# [ ] Form validation shows inline errors
# [ ] App icon displays correctly
# [ ] Splash screen shows on cold start
# [ ] VoiceOver/TalkBack reads content correctly
```

## Files to Create/Modify
- `composeApp/src/commonMain/kotlin/.../domain/error/AppError.kt`
- `composeApp/src/commonMain/kotlin/.../domain/error/ErrorHandler.kt`
- `composeApp/src/androidMain/kotlin/.../presentation/components/ErrorSnackbar.kt`
- `composeApp/src/androidMain/kotlin/.../presentation/components/ErrorScreen.kt`
- `composeApp/src/androidMain/kotlin/.../presentation/components/LoadingIndicators.kt`
- `composeApp/src/androidMain/kotlin/.../presentation/components/EmptyStates.kt`
- `composeApp/src/androidMain/kotlin/.../presentation/components/OfflineBanner.kt`
- `composeApp/src/commonMain/kotlin/.../domain/validation/Validators.kt`
- `composeApp/src/androidMain/res/values/themes.xml` (splash theme)
- `composeApp/src/androidMain/res/mipmap-*/ic_launcher.png`
- `iosApp/iosApp/Assets.xcassets/AppIcon.appiconset/`
- `iosApp/iosApp/LaunchScreen.storyboard`
- `composeApp/src/commonMain/kotlin/.../presentation/accessibility/AccessibilityUtils.kt`
- `composeApp/src/commonMain/kotlin/.../domain/analytics/AnalyticsEvent.kt` (optional)
- Update all screens to use error handling and loading states
