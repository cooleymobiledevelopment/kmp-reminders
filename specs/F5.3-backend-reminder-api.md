# F5.3: Backend Reminder API - CRUD Endpoints

## Objective
Implement CRUD endpoints for reminders with sync support (updatedAt timestamps, soft deletes).

## Dependencies
- F5.1 (Backend setup)
- F5.2 (Authentication)

## Requirements
- [ ] GET /reminders - List all reminders for user
- [ ] GET /reminders/:id - Get single reminder
- [ ] POST /reminders - Create reminder
- [ ] PUT /reminders/:id - Update reminder
- [ ] DELETE /reminders/:id - Soft delete reminder
- [ ] GET /reminders/sync?since=timestamp - Get changes since timestamp
- [ ] POST /reminders/batch - Batch create/update for sync
- [ ] All endpoints require authentication
- [ ] Filter by status, label, date range

## Reminder DTOs

### domain/models/ReminderModels.kt
```kotlin
package com.cooleymd.reminders.domain.models

import kotlinx.datetime.Instant
import kotlinx.serialization.Serializable

@Serializable
data class ReminderRequest(
    val id: String? = null, // For sync - client can provide ID
    val title: String,
    val notes: String? = null,
    val scheduledAt: Instant,
    val recurrenceRule: RecurrenceRuleDto? = null,
    val status: String = "PENDING",
    val snoozedUntil: Instant? = null,
    val completedAt: Instant? = null,
    val labelId: String? = null,
    val priority: String = "NORMAL"
)

@Serializable
data class ReminderResponse(
    val id: String,
    val title: String,
    val notes: String?,
    val scheduledAt: Instant,
    val recurrenceRule: RecurrenceRuleDto?,
    val status: String,
    val snoozedUntil: Instant?,
    val completedAt: Instant?,
    val labelId: String?,
    val priority: String,
    val createdAt: Instant,
    val updatedAt: Instant,
    val deletedAt: Instant? = null
)

@Serializable
data class RecurrenceRuleDto(
    val frequency: String, // DAILY, WEEKLY, MONTHLY, YEARLY
    val interval: Int = 1,
    val daysOfWeek: List<Int>? = null,
    val endDate: Instant? = null,
    val count: Int? = null
)

@Serializable
data class ReminderListResponse(
    val reminders: List<ReminderResponse>,
    val total: Int,
    val hasMore: Boolean = false
)

@Serializable
data class SyncResponse(
    val reminders: List<ReminderResponse>,
    val labels: List<LabelResponse>,
    val serverTimestamp: Instant
)

@Serializable
data class BatchSyncRequest(
    val reminders: List<ReminderRequest>,
    val labels: List<LabelRequest>? = null,
    val lastSyncTimestamp: Instant? = null
)

@Serializable
data class BatchSyncResponse(
    val created: List<ReminderResponse>,
    val updated: List<ReminderResponse>,
    val conflicts: List<SyncConflict>,
    val serverTimestamp: Instant
)

@Serializable
data class SyncConflict(
    val clientVersion: ReminderRequest,
    val serverVersion: ReminderResponse,
    val conflictType: String // "UPDATE_CONFLICT", "DELETE_CONFLICT"
)

@Serializable
data class LabelRequest(
    val id: String? = null,
    val name: String,
    val color: String
)

@Serializable
data class LabelResponse(
    val id: String,
    val name: String,
    val color: String,
    val createdAt: Instant,
    val updatedAt: Instant,
    val deletedAt: Instant? = null
)
```

## Reminder Repository

### data/repositories/ReminderRepository.kt
```kotlin
package com.cooleymd.reminders.data.repositories

import com.cooleymd.reminders.data.tables.RemindersTable
import com.cooleymd.reminders.domain.models.RecurrenceRuleDto
import com.cooleymd.reminders.domain.models.ReminderRequest
import com.cooleymd.reminders.domain.models.ReminderResponse
import kotlinx.datetime.Clock
import kotlinx.datetime.Instant
import kotlinx.serialization.encodeToString
import kotlinx.serialization.json.Json
import org.jetbrains.exposed.sql.*
import org.jetbrains.exposed.sql.SqlExpressionBuilder.eq
import org.jetbrains.exposed.sql.transactions.transaction
import java.util.*

class ReminderRepository {

    private val json = Json { ignoreUnknownKeys = true }

    fun findAllByUserId(
        userId: String,
        status: String? = null,
        labelId: String? = null,
        includeDeleted: Boolean = false
    ): List<ReminderResponse> {
        return transaction {
            val query = RemindersTable.select {
                var condition = RemindersTable.userId eq UUID.fromString(userId)

                if (!includeDeleted) {
                    condition = condition and RemindersTable.deletedAt.isNull()
                }

                status?.let {
                    condition = condition and (RemindersTable.status eq it)
                }

                labelId?.let {
                    condition = condition and (RemindersTable.labelId eq UUID.fromString(it))
                }

                condition
            }.orderBy(RemindersTable.scheduledAt)

            query.map { it.toReminderResponse() }
        }
    }

    fun findById(userId: String, reminderId: String): ReminderResponse? {
        return transaction {
            RemindersTable.select {
                (RemindersTable.id eq UUID.fromString(reminderId)) and
                (RemindersTable.userId eq UUID.fromString(userId))
            }.firstOrNull()?.toReminderResponse()
        }
    }

    fun findChangesSince(userId: String, since: Instant): List<ReminderResponse> {
        return transaction {
            RemindersTable.select {
                (RemindersTable.userId eq UUID.fromString(userId)) and
                (RemindersTable.updatedAt greater since)
            }.map { it.toReminderResponse() }
        }
    }

    fun create(userId: String, request: ReminderRequest): ReminderResponse {
        val now = Clock.System.now()
        val reminderId = request.id?.let { UUID.fromString(it) } ?: UUID.randomUUID()

        return transaction {
            RemindersTable.insert {
                it[id] = reminderId
                it[RemindersTable.userId] = UUID.fromString(userId)
                it[title] = request.title
                it[notes] = request.notes
                it[scheduledAt] = request.scheduledAt
                it[recurrenceRule] = request.recurrenceRule?.let { rule -> json.encodeToString(rule) }
                it[status] = request.status
                it[snoozedUntil] = request.snoozedUntil
                it[completedAt] = request.completedAt
                it[labelId] = request.labelId?.let { id -> UUID.fromString(id) }
                it[priority] = request.priority
                it[createdAt] = now
                it[updatedAt] = now
            }

            findById(userId, reminderId.toString())!!
        }
    }

    fun update(userId: String, reminderId: String, request: ReminderRequest): ReminderResponse? {
        val now = Clock.System.now()

        return transaction {
            val updated = RemindersTable.update({
                (RemindersTable.id eq UUID.fromString(reminderId)) and
                (RemindersTable.userId eq UUID.fromString(userId)) and
                RemindersTable.deletedAt.isNull()
            }) {
                it[title] = request.title
                it[notes] = request.notes
                it[scheduledAt] = request.scheduledAt
                it[recurrenceRule] = request.recurrenceRule?.let { rule -> json.encodeToString(rule) }
                it[status] = request.status
                it[snoozedUntil] = request.snoozedUntil
                it[completedAt] = request.completedAt
                it[labelId] = request.labelId?.let { id -> UUID.fromString(id) }
                it[priority] = request.priority
                it[updatedAt] = now
            }

            if (updated > 0) findById(userId, reminderId) else null
        }
    }

    fun softDelete(userId: String, reminderId: String): Boolean {
        val now = Clock.System.now()

        return transaction {
            val deleted = RemindersTable.update({
                (RemindersTable.id eq UUID.fromString(reminderId)) and
                (RemindersTable.userId eq UUID.fromString(userId)) and
                RemindersTable.deletedAt.isNull()
            }) {
                it[deletedAt] = now
                it[updatedAt] = now
            }

            deleted > 0
        }
    }

    fun upsert(userId: String, request: ReminderRequest): Pair<ReminderResponse, Boolean> {
        return transaction {
            val existingId = request.id
            if (existingId != null) {
                val existing = findById(userId, existingId)
                if (existing != null) {
                    // Update existing
                    val updated = update(userId, existingId, request)!!
                    return@transaction updated to false // Not created, updated
                }
            }
            // Create new
            val created = create(userId, request)
            created to true // Created
        }
    }

    private fun ResultRow.toReminderResponse(): ReminderResponse {
        return ReminderResponse(
            id = this[RemindersTable.id].toString(),
            title = this[RemindersTable.title],
            notes = this[RemindersTable.notes],
            scheduledAt = this[RemindersTable.scheduledAt],
            recurrenceRule = this[RemindersTable.recurrenceRule]?.let {
                json.decodeFromString<RecurrenceRuleDto>(it)
            },
            status = this[RemindersTable.status],
            snoozedUntil = this[RemindersTable.snoozedUntil],
            completedAt = this[RemindersTable.completedAt],
            labelId = this[RemindersTable.labelId]?.toString(),
            priority = this[RemindersTable.priority],
            createdAt = this[RemindersTable.createdAt],
            updatedAt = this[RemindersTable.updatedAt],
            deletedAt = this[RemindersTable.deletedAt]
        )
    }
}
```

## Reminder Routes

### routes/ReminderRoutes.kt
```kotlin
package com.cooleymd.reminders.routes

import com.cooleymd.reminders.data.repositories.ReminderRepository
import com.cooleymd.reminders.domain.models.*
import com.cooleymd.reminders.plugins.userId
import io.ktor.http.*
import io.ktor.server.application.*
import io.ktor.server.auth.*
import io.ktor.server.request.*
import io.ktor.server.response.*
import io.ktor.server.routing.*
import kotlinx.datetime.Clock
import kotlinx.datetime.Instant

fun Route.reminderRoutes(reminderRepository: ReminderRepository) {

    authenticate("auth-jwt") {
        route("/reminders") {

            // List all reminders
            get {
                val userId = call.userId ?: return@get call.respond(HttpStatusCode.Unauthorized)

                val status = call.parameters["status"]
                val labelId = call.parameters["labelId"]

                val reminders = reminderRepository.findAllByUserId(
                    userId = userId,
                    status = status,
                    labelId = labelId
                )

                call.respond(ReminderListResponse(
                    reminders = reminders,
                    total = reminders.size
                ))
            }

            // Get single reminder
            get("/{id}") {
                val userId = call.userId ?: return@get call.respond(HttpStatusCode.Unauthorized)
                val reminderId = call.parameters["id"] ?: return@get call.respond(HttpStatusCode.BadRequest)

                val reminder = reminderRepository.findById(userId, reminderId)

                if (reminder == null) {
                    call.respond(HttpStatusCode.NotFound, ErrorResponse("not_found", "Reminder not found"))
                } else {
                    call.respond(reminder)
                }
            }

            // Create reminder
            post {
                val userId = call.userId ?: return@post call.respond(HttpStatusCode.Unauthorized)
                val request = call.receive<ReminderRequest>()

                // Validate
                if (request.title.isBlank()) {
                    call.respond(
                        HttpStatusCode.BadRequest,
                        ErrorResponse("invalid_title", "Title is required")
                    )
                    return@post
                }

                val reminder = reminderRepository.create(userId, request)
                call.respond(HttpStatusCode.Created, reminder)
            }

            // Update reminder
            put("/{id}") {
                val userId = call.userId ?: return@put call.respond(HttpStatusCode.Unauthorized)
                val reminderId = call.parameters["id"] ?: return@put call.respond(HttpStatusCode.BadRequest)
                val request = call.receive<ReminderRequest>()

                val updated = reminderRepository.update(userId, reminderId, request)

                if (updated == null) {
                    call.respond(HttpStatusCode.NotFound, ErrorResponse("not_found", "Reminder not found"))
                } else {
                    call.respond(updated)
                }
            }

            // Delete reminder (soft delete)
            delete("/{id}") {
                val userId = call.userId ?: return@delete call.respond(HttpStatusCode.Unauthorized)
                val reminderId = call.parameters["id"] ?: return@delete call.respond(HttpStatusCode.BadRequest)

                val deleted = reminderRepository.softDelete(userId, reminderId)

                if (!deleted) {
                    call.respond(HttpStatusCode.NotFound, ErrorResponse("not_found", "Reminder not found"))
                } else {
                    call.respond(HttpStatusCode.NoContent)
                }
            }

            // Sync endpoint - get changes since timestamp
            get("/sync") {
                val userId = call.userId ?: return@get call.respond(HttpStatusCode.Unauthorized)
                val sinceParam = call.parameters["since"]

                val since = sinceParam?.let {
                    try {
                        Instant.parse(it)
                    } catch (e: Exception) {
                        return@get call.respond(
                            HttpStatusCode.BadRequest,
                            ErrorResponse("invalid_timestamp", "Invalid 'since' timestamp format")
                        )
                    }
                } ?: Instant.fromEpochMilliseconds(0)

                val reminders = reminderRepository.findChangesSince(userId, since)

                call.respond(SyncResponse(
                    reminders = reminders,
                    labels = emptyList(), // Add label sync later
                    serverTimestamp = Clock.System.now()
                ))
            }

            // Batch sync endpoint
            post("/sync") {
                val userId = call.userId ?: return@post call.respond(HttpStatusCode.Unauthorized)
                val request = call.receive<BatchSyncRequest>()

                val created = mutableListOf<ReminderResponse>()
                val updated = mutableListOf<ReminderResponse>()
                val conflicts = mutableListOf<SyncConflict>()

                for (reminderRequest in request.reminders) {
                    try {
                        // Check for conflicts
                        if (reminderRequest.id != null && request.lastSyncTimestamp != null) {
                            val existing = reminderRepository.findById(userId, reminderRequest.id)
                            if (existing != null && existing.updatedAt > request.lastSyncTimestamp) {
                                // Conflict detected
                                conflicts.add(SyncConflict(
                                    clientVersion = reminderRequest,
                                    serverVersion = existing,
                                    conflictType = if (existing.deletedAt != null) "DELETE_CONFLICT" else "UPDATE_CONFLICT"
                                ))
                                continue
                            }
                        }

                        val (reminder, wasCreated) = reminderRepository.upsert(userId, reminderRequest)
                        if (wasCreated) {
                            created.add(reminder)
                        } else {
                            updated.add(reminder)
                        }
                    } catch (e: Exception) {
                        // Log and skip failed items
                        println("Failed to sync reminder: ${e.message}")
                    }
                }

                call.respond(BatchSyncResponse(
                    created = created,
                    updated = updated,
                    conflicts = conflicts,
                    serverTimestamp = Clock.System.now()
                ))
            }
        }
    }
}
```

## Update Routing Plugin

### plugins/Routing.kt (updated)
```kotlin
package com.cooleymd.reminders.plugins

import com.cooleymd.reminders.data.repositories.ReminderRepository
import com.cooleymd.reminders.data.repositories.UserRepository
import com.cooleymd.reminders.domain.services.JwtService
import com.cooleymd.reminders.routes.authRoutes
import com.cooleymd.reminders.routes.healthRoutes
import com.cooleymd.reminders.routes.reminderRoutes
import io.ktor.server.application.*
import io.ktor.server.auth.*
import io.ktor.server.plugins.callloging.*
import io.ktor.server.plugins.statuspages.*
import io.ktor.server.response.*
import io.ktor.server.routing.*
import io.ktor.http.*
import org.slf4j.event.Level

fun Application.configureRouting() {
    val userRepository = UserRepository()
    val reminderRepository = ReminderRepository()
    val jwtService = JwtService(environment)

    install(CallLogging) {
        level = Level.INFO
    }

    install(StatusPages) {
        exception<Throwable> { call, cause ->
            call.application.log.error("Unhandled exception", cause)
            call.respond(
                HttpStatusCode.InternalServerError,
                mapOf("error" to "internal_error", "message" to (cause.message ?: "Internal server error"))
            )
        }
    }

    routing {
        healthRoutes()
        authRoutes(userRepository, jwtService)
        reminderRoutes(reminderRepository)

        authenticate("auth-jwt") {
            get("/me") {
                val userId = call.userId ?: return@get call.respond(HttpStatusCode.Unauthorized)
                val user = userRepository.findById(userId)
                if (user == null) {
                    call.respond(HttpStatusCode.NotFound)
                    return@get
                }
                call.respond(user)
            }
        }
    }
}
```

## Verification

```bash
# Start the server
./gradlew run

# Login first to get access token
ACCESS_TOKEN=$(curl -s -X POST http://localhost:8080/auth/login \
  -H "Content-Type: application/json" \
  -d '{"email": "test@example.com", "password": "password123"}' | jq -r '.accessToken')

# Create a reminder
curl -X POST http://localhost:8080/reminders \
  -H "Authorization: Bearer $ACCESS_TOKEN" \
  -H "Content-Type: application/json" \
  -d '{
    "title": "Test Reminder",
    "notes": "This is a test",
    "scheduledAt": "2024-12-25T10:00:00Z",
    "priority": "HIGH"
  }'

# List all reminders
curl http://localhost:8080/reminders \
  -H "Authorization: Bearer $ACCESS_TOKEN"

# Get a specific reminder
curl http://localhost:8080/reminders/<reminder-id> \
  -H "Authorization: Bearer $ACCESS_TOKEN"

# Update a reminder
curl -X PUT http://localhost:8080/reminders/<reminder-id> \
  -H "Authorization: Bearer $ACCESS_TOKEN" \
  -H "Content-Type: application/json" \
  -d '{
    "title": "Updated Reminder",
    "notes": "Updated notes",
    "scheduledAt": "2024-12-26T10:00:00Z",
    "status": "COMPLETED"
  }'

# Delete a reminder
curl -X DELETE http://localhost:8080/reminders/<reminder-id> \
  -H "Authorization: Bearer $ACCESS_TOKEN"

# Sync changes since timestamp
curl "http://localhost:8080/reminders/sync?since=2024-01-01T00:00:00Z" \
  -H "Authorization: Bearer $ACCESS_TOKEN"

# Batch sync
curl -X POST http://localhost:8080/reminders/sync \
  -H "Authorization: Bearer $ACCESS_TOKEN" \
  -H "Content-Type: application/json" \
  -d '{
    "reminders": [
      {"id": "uuid1", "title": "Synced Reminder 1", "scheduledAt": "2024-12-27T10:00:00Z"},
      {"title": "New Reminder from Client", "scheduledAt": "2024-12-28T10:00:00Z"}
    ],
    "lastSyncTimestamp": "2024-01-15T00:00:00Z"
  }'
```

## Files to Create/Modify
- `backend/src/main/kotlin/com/cooleymd/reminders/domain/models/ReminderModels.kt`
- `backend/src/main/kotlin/com/cooleymd/reminders/data/repositories/ReminderRepository.kt`
- `backend/src/main/kotlin/com/cooleymd/reminders/routes/ReminderRoutes.kt`
- Update `backend/src/main/kotlin/com/cooleymd/reminders/plugins/Routing.kt`
