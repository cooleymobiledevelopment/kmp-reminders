# F6.1: RevenueCat SDK Setup

## Objective
Integrate RevenueCat SDK for managing in-app purchases and subscriptions.

## Dependencies
- F0.1 (Project setup)
- RevenueCat account with app configured

## Requirements
- [ ] RevenueCat SDK added to both platforms
- [ ] SDK initialized on app launch
- [ ] User identification (anonymous and logged-in)
- [ ] Products/offerings fetched
- [ ] Purchase state observable
- [ ] Entitlement checking
- [ ] Restore purchases functionality

## RevenueCat Configuration

### Products to Configure in RevenueCat Dashboard
1. **Premium Monthly** - `com.cooleymd.reminders.premium.monthly`
   - $4.99/month
   - Unlimited reminders, cloud sync, multiple labels

2. **Premium Annual** - `com.cooleymd.reminders.premium.annual`
   - $39.99/year (save 33%)
   - Same features as monthly

### Entitlements
- `premium` - Access to all premium features

### Offerings
- `default` - Contains both monthly and annual packages

## Dependencies

> **Note**: Verify the latest SDK versions before implementation at:
> - Android: https://github.com/RevenueCat/purchases-android/releases
> - iOS: https://github.com/RevenueCat/purchases-ios/releases

### Android - build.gradle.kts
```kotlin
dependencies {
    // RevenueCat SDK - verify latest version
    implementation("com.revenuecat.purchases:purchases:8.2.0")
    implementation("com.revenuecat.purchases:purchases-ui:8.2.0") // For Paywall UI
}
```

### iOS - Podfile or SPM
```ruby
# Podfile - verify latest version
pod 'RevenueCat', '~> 5.2'
pod 'RevenueCatUI', '~> 5.2'
```

Or with Swift Package Manager (recommended):
- Add `https://github.com/RevenueCat/purchases-ios.git`
- Select version 5.2.0 or later

## Shared Purchase Manager

### domain/purchase/PurchaseManager.kt
```kotlin
package com.cooleymd.reminders.domain.purchase

import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.StateFlow

// Shared interface for KMP
interface PurchaseManager {
    val isPremium: StateFlow<Boolean>
    val offerings: StateFlow<OfferingsState>

    suspend fun initialize()
    suspend fun login(userId: String)
    suspend fun logout()
    suspend fun fetchOfferings()
    suspend fun purchase(packageId: String): PurchaseResult
    suspend fun restorePurchases(): RestoreResult
    fun checkEntitlement(entitlementId: String): Boolean
}

sealed class OfferingsState {
    object Loading : OfferingsState()
    data class Success(val offerings: List<OfferingInfo>) : OfferingsState()
    data class Error(val message: String) : OfferingsState()
}

data class OfferingInfo(
    val identifier: String,
    val packages: List<PackageInfo>
)

data class PackageInfo(
    val identifier: String,
    val productId: String,
    val localizedPrice: String,
    val localizedPricePerMonth: String?,
    val packageType: PackageType
)

enum class PackageType {
    MONTHLY, ANNUAL, LIFETIME, WEEKLY, UNKNOWN
}

sealed class PurchaseResult {
    data class Success(val entitlements: List<String>) : PurchaseResult()
    object Cancelled : PurchaseResult()
    data class Error(val message: String) : PurchaseResult()
}

sealed class RestoreResult {
    data class Success(val entitlements: List<String>) : RestoreResult()
    data class Error(val message: String) : RestoreResult()
}
```

## Android Implementation

### data/purchase/AndroidPurchaseManager.kt
```kotlin
package com.cooleymd.reminders.data.purchase

import android.app.Application
import com.cooleymd.reminders.domain.purchase.*
import com.revenuecat.purchases.*
import com.revenuecat.purchases.models.StoreTransaction
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.suspendCancellableCoroutine
import kotlin.coroutines.resume

class AndroidPurchaseManager(
    private val application: Application
) : PurchaseManager {

    private val _isPremium = MutableStateFlow(false)
    override val isPremium: StateFlow<Boolean> = _isPremium

    private val _offerings = MutableStateFlow<OfferingsState>(OfferingsState.Loading)
    override val offerings: StateFlow<OfferingsState> = _offerings

    override suspend fun initialize() {
        Purchases.logLevel = LogLevel.DEBUG // Remove in production

        Purchases.configure(
            PurchasesConfiguration.Builder(
                application,
                apiKey = BuildConfig.REVENUECAT_API_KEY
            ).build()
        )

        // Set up customer info listener
        Purchases.sharedInstance.updatedCustomerInfoListener =
            UpdatedCustomerInfoListener { customerInfo ->
                _isPremium.value = customerInfo.entitlements["premium"]?.isActive == true
            }

        // Check initial state
        checkPremiumStatus()
    }

    override suspend fun login(userId: String) {
        suspendCancellableCoroutine { continuation ->
            Purchases.sharedInstance.logIn(
                userId,
                object : LogInCallback {
                    override fun onReceived(customerInfo: CustomerInfo, created: Boolean) {
                        _isPremium.value = customerInfo.entitlements["premium"]?.isActive == true
                        continuation.resume(Unit)
                    }

                    override fun onError(error: PurchasesError) {
                        continuation.resume(Unit)
                    }
                }
            )
        }
    }

    override suspend fun logout() {
        Purchases.sharedInstance.logOut()
        _isPremium.value = false
    }

    override suspend fun fetchOfferings() {
        _offerings.value = OfferingsState.Loading

        suspendCancellableCoroutine { continuation ->
            Purchases.sharedInstance.getOfferings(object : ReceiveOfferingsCallback {
                override fun onReceived(offerings: Offerings) {
                    val offeringsList = offerings.all.map { (id, offering) ->
                        OfferingInfo(
                            identifier = id,
                            packages = offering.availablePackages.map { pkg ->
                                PackageInfo(
                                    identifier = pkg.identifier,
                                    productId = pkg.product.id,
                                    localizedPrice = pkg.product.price.formatted,
                                    localizedPricePerMonth = calculateMonthlyPrice(pkg),
                                    packageType = pkg.packageType.toShared()
                                )
                            }
                        )
                    }
                    _offerings.value = OfferingsState.Success(offeringsList)
                    continuation.resume(Unit)
                }

                override fun onError(error: PurchasesError) {
                    _offerings.value = OfferingsState.Error(error.message)
                    continuation.resume(Unit)
                }
            })
        }
    }

    override suspend fun purchase(packageId: String): PurchaseResult {
        // This needs to be called from an Activity context
        // Typically handled through a callback or activity reference
        return PurchaseResult.Error("Use purchaseFromActivity instead")
    }

    suspend fun purchaseFromActivity(
        activity: android.app.Activity,
        packageId: String
    ): PurchaseResult {
        val offerings = (offerings.value as? OfferingsState.Success)?.offerings
            ?: return PurchaseResult.Error("Offerings not loaded")

        val pkg = offerings.flatMap { it.packages }
            .find { it.identifier == packageId }
            ?: return PurchaseResult.Error("Package not found")

        return suspendCancellableCoroutine { continuation ->
            Purchases.sharedInstance.getOfferings(object : ReceiveOfferingsCallback {
                override fun onReceived(offerings: Offerings) {
                    val rcPackage = offerings.current?.availablePackages
                        ?.find { it.identifier == packageId }

                    if (rcPackage == null) {
                        continuation.resume(PurchaseResult.Error("Package not found"))
                        return
                    }

                    Purchases.sharedInstance.purchase(
                        PurchaseParams.Builder(activity, rcPackage).build(),
                        object : PurchaseCallback {
                            override fun onCompleted(
                                storeTransaction: StoreTransaction,
                                customerInfo: CustomerInfo
                            ) {
                                _isPremium.value = customerInfo.entitlements["premium"]?.isActive == true
                                val entitlements = customerInfo.entitlements.active.keys.toList()
                                continuation.resume(PurchaseResult.Success(entitlements))
                            }

                            override fun onError(error: PurchasesError, userCancelled: Boolean) {
                                if (userCancelled) {
                                    continuation.resume(PurchaseResult.Cancelled)
                                } else {
                                    continuation.resume(PurchaseResult.Error(error.message))
                                }
                            }
                        }
                    )
                }

                override fun onError(error: PurchasesError) {
                    continuation.resume(PurchaseResult.Error(error.message))
                }
            })
        }
    }

    override suspend fun restorePurchases(): RestoreResult {
        return suspendCancellableCoroutine { continuation ->
            Purchases.sharedInstance.restorePurchases(object : ReceiveCustomerInfoCallback {
                override fun onReceived(customerInfo: CustomerInfo) {
                    _isPremium.value = customerInfo.entitlements["premium"]?.isActive == true
                    val entitlements = customerInfo.entitlements.active.keys.toList()
                    continuation.resume(RestoreResult.Success(entitlements))
                }

                override fun onError(error: PurchasesError) {
                    continuation.resume(RestoreResult.Error(error.message))
                }
            })
        }
    }

    override fun checkEntitlement(entitlementId: String): Boolean {
        return Purchases.sharedInstance.cachedCustomerInfo
            ?.entitlements
            ?.get(entitlementId)
            ?.isActive == true
    }

    private suspend fun checkPremiumStatus() {
        suspendCancellableCoroutine { continuation ->
            Purchases.sharedInstance.getCustomerInfo(object : ReceiveCustomerInfoCallback {
                override fun onReceived(customerInfo: CustomerInfo) {
                    _isPremium.value = customerInfo.entitlements["premium"]?.isActive == true
                    continuation.resume(Unit)
                }

                override fun onError(error: PurchasesError) {
                    continuation.resume(Unit)
                }
            })
        }
    }

    private fun calculateMonthlyPrice(pkg: Package): String? {
        return when (pkg.packageType) {
            PackageType.ANNUAL -> {
                val annualPrice = pkg.product.price.amountMicros
                val monthlyPrice = annualPrice / 12
                // Format as currency
                "$${monthlyPrice / 1_000_000.0}/mo"
            }
            else -> null
        }
    }

    private fun com.revenuecat.purchases.PackageType.toShared(): PackageType {
        return when (this) {
            com.revenuecat.purchases.PackageType.MONTHLY -> PackageType.MONTHLY
            com.revenuecat.purchases.PackageType.ANNUAL -> PackageType.ANNUAL
            com.revenuecat.purchases.PackageType.LIFETIME -> PackageType.LIFETIME
            com.revenuecat.purchases.PackageType.WEEKLY -> PackageType.WEEKLY
            else -> PackageType.UNKNOWN
        }
    }
}
```

## iOS Implementation

### iosApp/Purchase/PurchaseManager.swift
```swift
import Foundation
import RevenueCat
import Combine

@MainActor
class IOSPurchaseManager: ObservableObject {
    static let shared = IOSPurchaseManager()

    @Published var isPremium: Bool = false
    @Published var offerings: [Offering] = []
    @Published var isLoading: Bool = false
    @Published var error: String?

    private var cancellables = Set<AnyCancellable>()

    private init() {}

    func configure() {
        Purchases.logLevel = .debug // Remove in production

        Purchases.configure(withAPIKey: Config.revenueCatApiKey)

        // Listen for customer info updates
        Purchases.shared.customerInfoStream
            .sink { [weak self] customerInfo in
                self?.isPremium = customerInfo.entitlements["premium"]?.isActive == true
            }
            .store(in: &cancellables)

        // Check initial state
        Task {
            await checkPremiumStatus()
        }
    }

    func login(userId: String) async {
        do {
            let (customerInfo, _) = try await Purchases.shared.logIn(userId)
            isPremium = customerInfo.entitlements["premium"]?.isActive == true
        } catch {
            print("Login error: \(error)")
        }
    }

    func logout() async {
        do {
            _ = try await Purchases.shared.logOut()
            isPremium = false
        } catch {
            print("Logout error: \(error)")
        }
    }

    func fetchOfferings() async {
        isLoading = true
        error = nil

        do {
            let offerings = try await Purchases.shared.offerings()
            self.offerings = offerings.all.values.map { $0 }
            isLoading = false
        } catch {
            self.error = error.localizedDescription
            isLoading = false
        }
    }

    func purchase(package: Package) async -> PurchaseResultType {
        do {
            let (_, customerInfo, _) = try await Purchases.shared.purchase(package: package)
            isPremium = customerInfo.entitlements["premium"]?.isActive == true
            let entitlements = customerInfo.entitlements.active.keys.map { $0 }
            return .success(entitlements: Array(entitlements))
        } catch let error as ErrorCode {
            if error == .purchaseCancelledError {
                return .cancelled
            }
            return .error(message: error.localizedDescription)
        } catch {
            return .error(message: error.localizedDescription)
        }
    }

    func restorePurchases() async -> RestoreResultType {
        do {
            let customerInfo = try await Purchases.shared.restorePurchases()
            isPremium = customerInfo.entitlements["premium"]?.isActive == true
            let entitlements = customerInfo.entitlements.active.keys.map { $0 }
            return .success(entitlements: Array(entitlements))
        } catch {
            return .error(message: error.localizedDescription)
        }
    }

    func checkEntitlement(_ entitlementId: String) -> Bool {
        return Purchases.shared.cachedCustomerInfo?.entitlements[entitlementId]?.isActive == true
    }

    private func checkPremiumStatus() async {
        do {
            let customerInfo = try await Purchases.shared.customerInfo()
            isPremium = customerInfo.entitlements["premium"]?.isActive == true
        } catch {
            print("Failed to get customer info: \(error)")
        }
    }
}

enum PurchaseResultType {
    case success(entitlements: [String])
    case cancelled
    case error(message: String)
}

enum RestoreResultType {
    case success(entitlements: [String])
    case error(message: String)
}
```

## Application Initialization

### Android - RemindersApplication.kt
```kotlin
class RemindersApplication : Application() {
    override fun onCreate() {
        super.onCreate()

        // Initialize Koin
        startKoin {
            androidContext(this@RemindersApplication)
            modules(appModule)
        }

        // Initialize RevenueCat
        val purchaseManager: AndroidPurchaseManager by inject()
        GlobalScope.launch {
            purchaseManager.initialize()
        }

        // Create notification channel
        ReminderNotificationChannel.createChannel(this)
    }
}
```

### iOS - RemindersApp.swift
```swift
@main
struct RemindersApp: App {
    @UIApplicationDelegateAdaptor(AppDelegate.self) var appDelegate
    @StateObject private var purchaseManager = IOSPurchaseManager.shared

    init() {
        IOSPurchaseManager.shared.configure()
    }

    var body: some Scene {
        WindowGroup {
            MainTabView()
                .environmentObject(purchaseManager)
        }
    }
}
```

## Build Configuration

### Android - local.properties or BuildConfig
```properties
# local.properties (don't commit)
REVENUECAT_API_KEY=your_public_api_key_here
```

### Android - build.gradle.kts
```kotlin
android {
    defaultConfig {
        buildConfigField(
            "String",
            "REVENUECAT_API_KEY",
            "\"${project.findProperty("REVENUECAT_API_KEY") ?: ""}\""
        )
    }
}
```

### iOS - Config.swift
```swift
enum Config {
    static let revenueCatApiKey = "your_public_api_key_here"
    // Or load from Info.plist / environment
}
```

## Verification

```kotlin
// Android test
class PurchaseManagerTest {

    @Test
    fun `premium status updates on purchase`() = runTest {
        val purchaseManager = AndroidPurchaseManager(application)
        purchaseManager.initialize()

        // Initial state
        assertFalse(purchaseManager.isPremium.value)

        // After purchase (mock or sandbox)
        // purchaseManager.purchaseFromActivity(...)
        // assertTrue(purchaseManager.isPremium.value)
    }

    @Test
    fun `offerings load successfully`() = runTest {
        val purchaseManager = AndroidPurchaseManager(application)
        purchaseManager.initialize()
        purchaseManager.fetchOfferings()

        val offerings = purchaseManager.offerings.value
        assertTrue(offerings is OfferingsState.Success)
    }
}
```

```bash
# Manual verification steps:
# 1. Build and run app
# 2. Check logs for RevenueCat initialization
# 3. Navigate to settings/paywall
# 4. Verify offerings display
# 5. Test purchase flow with sandbox account
# 6. Verify entitlement active after purchase
# 7. Test restore purchases
```

## Files to Create/Modify
- `composeApp/src/commonMain/kotlin/.../domain/purchase/PurchaseManager.kt`
- `composeApp/src/androidMain/kotlin/.../data/purchase/AndroidPurchaseManager.kt`
- `iosApp/iosApp/Purchase/PurchaseManager.swift`
- `iosApp/iosApp/Purchase/Config.swift`
- Update `composeApp/build.gradle.kts` with RevenueCat dependency
- Update `iosApp/Podfile` or add SPM package
- Update `RemindersApplication.kt` for initialization
- Update `RemindersApp.swift` for initialization
- Update `di/AppModule.kt` to provide PurchaseManager
