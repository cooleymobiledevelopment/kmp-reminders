# F5.5: Client Sync - Download and Merge Server Changes

## Objective
Implement client-side logic to fetch and merge server changes with local data.

## Dependencies
- F5.4 (Upload sync)
- F5.3 (Backend API)

## Requirements
- [ ] Periodic background sync
- [ ] Merge server changes into local database
- [ ] Handle deleted items from server
- [ ] Conflict detection and resolution UI
- [ ] Network connectivity monitoring
- [ ] Sync status indicator in UI

## Network Connectivity Monitor

### data/network/ConnectivityMonitor.kt
```kotlin
package com.cooleymd.reminders.data.network

import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.StateFlow

expect class ConnectivityMonitor {
    val isConnected: StateFlow<Boolean>
    fun startMonitoring()
    fun stopMonitoring()
}
```

### Android Implementation
```kotlin
package com.cooleymd.reminders.data.network

import android.content.Context
import android.net.ConnectivityManager
import android.net.Network
import android.net.NetworkCapabilities
import android.net.NetworkRequest
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow

actual class ConnectivityMonitor(context: Context) {
    private val connectivityManager = context.getSystemService(Context.CONNECTIVITY_SERVICE) as ConnectivityManager

    private val _isConnected = MutableStateFlow(checkConnection())
    actual val isConnected: StateFlow<Boolean> = _isConnected

    private val networkCallback = object : ConnectivityManager.NetworkCallback() {
        override fun onAvailable(network: Network) {
            _isConnected.value = true
        }

        override fun onLost(network: Network) {
            _isConnected.value = checkConnection()
        }

        override fun onCapabilitiesChanged(network: Network, capabilities: NetworkCapabilities) {
            _isConnected.value = capabilities.hasCapability(NetworkCapabilities.NET_CAPABILITY_INTERNET)
        }
    }

    actual fun startMonitoring() {
        val request = NetworkRequest.Builder()
            .addCapability(NetworkCapabilities.NET_CAPABILITY_INTERNET)
            .build()
        connectivityManager.registerNetworkCallback(request, networkCallback)
    }

    actual fun stopMonitoring() {
        connectivityManager.unregisterNetworkCallback(networkCallback)
    }

    private fun checkConnection(): Boolean {
        val network = connectivityManager.activeNetwork ?: return false
        val capabilities = connectivityManager.getNetworkCapabilities(network) ?: return false
        return capabilities.hasCapability(NetworkCapabilities.NET_CAPABILITY_INTERNET)
    }
}
```

### iOS Implementation
```kotlin
package com.cooleymd.reminders.data.network

import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import platform.Network.*
import platform.darwin.dispatch_get_main_queue

actual class ConnectivityMonitor {
    private val _isConnected = MutableStateFlow(true)
    actual val isConnected: StateFlow<Boolean> = _isConnected

    private val monitor = nw_path_monitor_create()

    actual fun startMonitoring() {
        nw_path_monitor_set_update_handler(monitor) { path ->
            val status = nw_path_get_status(path)
            _isConnected.value = status == nw_path_status_satisfied
        }
        nw_path_monitor_set_queue(monitor, dispatch_get_main_queue())
        nw_path_monitor_start(monitor)
    }

    actual fun stopMonitoring() {
        nw_path_monitor_cancel(monitor)
    }
}
```

## Background Sync Worker (Android)

### data/sync/SyncWorker.kt (Android)
```kotlin
package com.cooleymd.reminders.data.sync

import android.content.Context
import androidx.work.*
import com.cooleymd.reminders.domain.sync.SyncManager
import com.cooleymd.reminders.domain.sync.SyncResult
import org.koin.core.component.KoinComponent
import org.koin.core.component.inject
import java.util.concurrent.TimeUnit

class SyncWorker(
    context: Context,
    params: WorkerParameters
) : CoroutineWorker(context, params), KoinComponent {

    private val syncManager: SyncManager by inject()

    override suspend fun doWork(): Result {
        return when (syncManager.sync()) {
            is SyncResult.Success -> Result.success()
            is SyncResult.AuthRequired -> Result.failure()
            is SyncResult.Error -> Result.retry()
            is SyncResult.AlreadySyncing -> Result.success()
        }
    }

    companion object {
        private const val WORK_NAME = "reminder_sync"

        fun schedule(context: Context) {
            val constraints = Constraints.Builder()
                .setRequiredNetworkType(NetworkType.CONNECTED)
                .build()

            val syncRequest = PeriodicWorkRequestBuilder<SyncWorker>(
                15, TimeUnit.MINUTES
            )
                .setConstraints(constraints)
                .setBackoffCriteria(
                    BackoffPolicy.EXPONENTIAL,
                    WorkRequest.MIN_BACKOFF_MILLIS,
                    TimeUnit.MILLISECONDS
                )
                .build()

            WorkManager.getInstance(context)
                .enqueueUniquePeriodicWork(
                    WORK_NAME,
                    ExistingPeriodicWorkPolicy.KEEP,
                    syncRequest
                )
        }

        fun triggerImmediateSync(context: Context) {
            val constraints = Constraints.Builder()
                .setRequiredNetworkType(NetworkType.CONNECTED)
                .build()

            val syncRequest = OneTimeWorkRequestBuilder<SyncWorker>()
                .setConstraints(constraints)
                .build()

            WorkManager.getInstance(context)
                .enqueue(syncRequest)
        }

        fun cancel(context: Context) {
            WorkManager.getInstance(context).cancelUniqueWork(WORK_NAME)
        }
    }
}
```

## iOS Background Sync

### iosApp/Sync/BackgroundSyncManager.swift
```swift
import Foundation
import BackgroundTasks
import Shared

class BackgroundSyncManager {
    static let shared = BackgroundSyncManager()
    static let taskIdentifier = "com.cooleymd.reminders.sync"

    private let syncManager: SyncManager

    private init() {
        self.syncManager = KMPBridge.shared.syncManager
    }

    func registerBackgroundTask() {
        BGTaskScheduler.shared.register(
            forTaskWithIdentifier: Self.taskIdentifier,
            using: nil
        ) { task in
            self.handleBackgroundSync(task: task as! BGAppRefreshTask)
        }
    }

    func scheduleBackgroundSync() {
        let request = BGAppRefreshTaskRequest(identifier: Self.taskIdentifier)
        request.earliestBeginDate = Date(timeIntervalSinceNow: 15 * 60) // 15 minutes

        do {
            try BGTaskScheduler.shared.submit(request)
        } catch {
            print("Failed to schedule background sync: \(error)")
        }
    }

    private func handleBackgroundSync(task: BGAppRefreshTask) {
        // Schedule next sync
        scheduleBackgroundSync()

        Task {
            let result = await syncManager.sync()

            switch result {
            case .success:
                task.setTaskCompleted(success: true)
            case .authRequired, .error:
                task.setTaskCompleted(success: false)
            default:
                task.setTaskCompleted(success: true)
            }
        }

        task.expirationHandler = {
            // Handle expiration
        }
    }
}
```

## Sync Repository Extensions

### Update ReminderRepositoryImpl for merge logic
```kotlin
class ReminderRepositoryImpl(
    private val database: RemindersDatabase
) : ReminderRepository {

    // ... existing methods ...

    override suspend fun insertFromServer(dto: ReminderSyncDto) {
        val queries = database.reminderQueries

        queries.insertReminder(
            id = dto.id,
            title = dto.title,
            notes = dto.notes,
            scheduledAt = dto.scheduledAt.toEpochMilliseconds(),
            recurrenceRule = dto.recurrenceRule,
            status = dto.status,
            snoozedUntil = dto.snoozedUntil?.toEpochMilliseconds(),
            completedAt = dto.completedAt?.toEpochMilliseconds(),
            labelId = dto.labelId,
            priority = dto.priority,
            createdAt = Clock.System.now().toEpochMilliseconds(),
            updatedAt = Clock.System.now().toEpochMilliseconds(),
            syncStatus = SyncStatus.SYNCED.name,
            serverId = dto.id,
            lastSyncedAt = Clock.System.now().toEpochMilliseconds()
        )
    }

    override suspend fun updateFromServer(dto: ReminderSyncDto) {
        val queries = database.reminderQueries

        queries.updateFromServer(
            title = dto.title,
            notes = dto.notes,
            scheduledAt = dto.scheduledAt.toEpochMilliseconds(),
            recurrenceRule = dto.recurrenceRule,
            status = dto.status,
            snoozedUntil = dto.snoozedUntil?.toEpochMilliseconds(),
            completedAt = dto.completedAt?.toEpochMilliseconds(),
            labelId = dto.labelId,
            priority = dto.priority,
            updatedAt = Clock.System.now().toEpochMilliseconds(),
            syncStatus = SyncStatus.SYNCED.name,
            lastSyncedAt = Clock.System.now().toEpochMilliseconds(),
            id = dto.id
        )
    }

    override suspend fun getPendingChanges(): List<Reminder> {
        return database.reminderQueries
            .selectPendingSync()
            .executeAsList()
            .map { it.toDomain() }
    }

    override suspend fun updateSyncStatus(id: String, status: SyncStatus) {
        database.reminderQueries.updateSyncStatus(
            syncStatus = status.name,
            lastSyncedAt = if (status == SyncStatus.SYNCED) Clock.System.now().toEpochMilliseconds() else null,
            id = id
        )
    }

    override suspend fun markAsDeleted(id: String) {
        database.reminderQueries.markAsDeleted(
            syncStatus = SyncStatus.PENDING_DELETE.name,
            updatedAt = Clock.System.now().toEpochMilliseconds(),
            id = id
        )
    }

    override suspend fun permanentlyDeleteSynced() {
        // Clean up items that have been synced as deleted
        database.reminderQueries.deleteSyncedDeleted()
    }
}
```

## SQLDelight Queries for Sync

### Reminder.sq additions
```sql
selectPendingSync:
SELECT *
FROM reminders
WHERE sync_status != 'SYNCED'
AND sync_status != 'CONFLICT';

updateSyncStatus:
UPDATE reminders
SET sync_status = ?, last_synced_at = ?
WHERE id = ?;

updateFromServer:
UPDATE reminders
SET title = ?,
    notes = ?,
    scheduled_at = ?,
    recurrence_rule = ?,
    status = ?,
    snoozed_until = ?,
    completed_at = ?,
    label_id = ?,
    priority = ?,
    updated_at = ?,
    sync_status = ?,
    last_synced_at = ?
WHERE id = ?;

markAsDeleted:
UPDATE reminders
SET sync_status = ?, updated_at = ?, status = 'DELETED'
WHERE id = ?;

deleteSyncedDeleted:
DELETE FROM reminders
WHERE sync_status = 'SYNCED' AND status = 'DELETED';
```

## Conflict Resolution UI

### Android - presentation/sync/ConflictResolutionScreen.kt
```kotlin
@Composable
fun ConflictResolutionScreen(
    conflicts: List<SyncConflict>,
    onResolve: (reminderId: String, resolution: ConflictResolution) -> Unit
) {
    LazyColumn {
        items(conflicts, key = { it.serverVersion.id }) { conflict ->
            ConflictCard(
                conflict = conflict,
                onKeepLocal = { onResolve(conflict.serverVersion.id, ConflictResolution.KEEP_LOCAL) },
                onKeepServer = { onResolve(conflict.serverVersion.id, ConflictResolution.KEEP_SERVER) },
                onKeepBoth = { onResolve(conflict.serverVersion.id, ConflictResolution.KEEP_BOTH) }
            )
        }
    }
}

@Composable
fun ConflictCard(
    conflict: SyncConflict,
    onKeepLocal: () -> Unit,
    onKeepServer: () -> Unit,
    onKeepBoth: () -> Unit
) {
    Card(
        modifier = Modifier
            .fillMaxWidth()
            .padding(16.dp)
    ) {
        Column(modifier = Modifier.padding(16.dp)) {
            Text(
                text = "Conflict Detected",
                style = MaterialTheme.typography.titleMedium,
                color = MaterialTheme.colorScheme.error
            )

            Spacer(Modifier.height(8.dp))

            Text("Your version:", style = MaterialTheme.typography.labelMedium)
            Text(conflict.clientVersion.title)
            Text(
                "Last modified: ${conflict.clientVersion.scheduledAt}",
                style = MaterialTheme.typography.bodySmall
            )

            Spacer(Modifier.height(8.dp))

            Text("Server version:", style = MaterialTheme.typography.labelMedium)
            Text(conflict.serverVersion.title)
            Text(
                "Last modified: ${conflict.serverVersion.scheduledAt}",
                style = MaterialTheme.typography.bodySmall
            )

            Spacer(Modifier.height(16.dp))

            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.SpaceEvenly
            ) {
                TextButton(onClick = onKeepLocal) {
                    Text("Keep Mine")
                }
                TextButton(onClick = onKeepServer) {
                    Text("Keep Server")
                }
                TextButton(onClick = onKeepBoth) {
                    Text("Keep Both")
                }
            }
        }
    }
}
```

## Sync Status Indicator

### presentation/components/SyncStatusIndicator.kt
```kotlin
@Composable
fun SyncStatusIndicator(
    syncState: SyncState,
    onSyncClick: () -> Unit,
    modifier: Modifier = Modifier
) {
    Row(
        modifier = modifier
            .clickable(onClick = onSyncClick)
            .padding(8.dp),
        verticalAlignment = Alignment.CenterVertically
    ) {
        when (syncState) {
            is SyncState.Idle -> {
                Icon(
                    Icons.Default.CloudDone,
                    contentDescription = "Synced",
                    tint = MaterialTheme.colorScheme.primary
                )
                Spacer(Modifier.width(4.dp))
                Text("Synced", style = MaterialTheme.typography.bodySmall)
            }
            is SyncState.Syncing -> {
                CircularProgressIndicator(
                    modifier = Modifier.size(16.dp),
                    strokeWidth = 2.dp
                )
                Spacer(Modifier.width(4.dp))
                Text("Syncing...", style = MaterialTheme.typography.bodySmall)
            }
            is SyncState.Success -> {
                Icon(
                    Icons.Default.CloudDone,
                    contentDescription = "Synced",
                    tint = MaterialTheme.colorScheme.primary
                )
                Spacer(Modifier.width(4.dp))
                Text(
                    "Synced ${syncState.lastSyncTime.formatRelative()}",
                    style = MaterialTheme.typography.bodySmall
                )
            }
            is SyncState.Error -> {
                Icon(
                    Icons.Default.CloudOff,
                    contentDescription = "Sync error",
                    tint = MaterialTheme.colorScheme.error
                )
                Spacer(Modifier.width(4.dp))
                Text(
                    "Sync error",
                    style = MaterialTheme.typography.bodySmall,
                    color = MaterialTheme.colorScheme.error
                )
            }
        }
    }
}
```

## Home Screen Integration

### Update HomeScreen to show sync status
```kotlin
@Composable
fun HomeScreen(
    viewModel: HomeViewModel = koinViewModel(),
    syncViewModel: SyncViewModel = koinViewModel(),
    onAddClick: () -> Unit,
    onReminderClick: (String) -> Unit
) {
    val uiState by viewModel.uiState.collectAsState()
    val syncState by syncViewModel.syncState.collectAsState()
    val conflicts by syncViewModel.conflicts.collectAsState()

    Scaffold(
        topBar = {
            TopAppBar(
                title = { Text("Reminders") },
                actions = {
                    SyncStatusIndicator(
                        syncState = syncState,
                        onSyncClick = { syncViewModel.triggerSync() }
                    )
                }
            )
        },
        // ... rest of scaffold
    ) { /* content */ }

    // Show conflict dialog if any
    if (conflicts.isNotEmpty()) {
        ConflictResolutionDialog(
            conflicts = conflicts,
            onResolve = { id, resolution ->
                syncViewModel.resolveConflict(id, resolution)
            }
        )
    }
}
```

## Verification

```kotlin
// Test sync flow:
class SyncIntegrationTest {

    @Test
    fun `offline changes sync when online`() = runTest {
        // 1. Create reminder while offline
        connectivityMonitor.setConnected(false)
        createReminderUseCase("Test reminder")

        // Verify pending sync status
        val reminder = reminderRepository.getAll().first()
        assertEquals(SyncStatus.PENDING_CREATE, reminder.syncStatus)

        // 2. Go online and sync
        connectivityMonitor.setConnected(true)
        syncManager.sync()

        // 3. Verify synced
        val syncedReminder = reminderRepository.getAll().first()
        assertEquals(SyncStatus.SYNCED, syncedReminder.syncStatus)
    }

    @Test
    fun `server changes merge correctly`() = runTest {
        // Create and sync initial reminder
        // Modify on "server" (mock API response)
        // Trigger sync
        // Verify local data updated
    }

    @Test
    fun `conflicts detected and shown`() = runTest {
        // Create reminder locally
        // Simulate server having different version
        // Trigger sync
        // Verify conflict in syncManager.conflicts
    }
}
```

## Files to Create/Modify
- `composeApp/src/commonMain/kotlin/.../data/network/ConnectivityMonitor.kt`
- `composeApp/src/androidMain/kotlin/.../data/network/ConnectivityMonitor.android.kt`
- `composeApp/src/iosMain/kotlin/.../data/network/ConnectivityMonitor.ios.kt`
- `composeApp/src/androidMain/kotlin/.../data/sync/SyncWorker.kt`
- `iosApp/iosApp/Sync/BackgroundSyncManager.swift`
- Update `composeApp/src/commonMain/sqldelight/.../Reminder.sq`
- Update `ReminderRepositoryImpl.kt` with sync merge logic
- `composeApp/src/androidMain/kotlin/.../presentation/sync/ConflictResolutionScreen.kt`
- `composeApp/src/commonMain/kotlin/.../presentation/components/SyncStatusIndicator.kt`
- Update `HomeScreen.kt` with sync status
- `composeApp/src/commonMain/kotlin/.../presentation/sync/SyncViewModel.kt`
- Update `di/AppModule.kt` with connectivity monitor and sync worker
