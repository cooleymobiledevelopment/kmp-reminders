# F5.4: Client Sync - Upload Local Changes

## Objective
Implement client-side sync logic to track and upload local changes to the server.

## Dependencies
- F5.3 (Backend API)
- F1.1 (Reminder model)
- F0.4 (Ktor client setup)

## Requirements
- [ ] Track local changes with sync status (pending, synced, conflict)
- [ ] Queue changes when offline
- [ ] Upload changes when online
- [ ] Handle sync conflicts
- [ ] Store auth tokens securely
- [ ] Automatic retry on failure
- [ ] Manual sync trigger

## Sync Status Model

### Update SQLDelight schema - Reminder.sq
```sql
-- Add sync columns to reminders table
ALTER TABLE reminders ADD COLUMN sync_status TEXT NOT NULL DEFAULT 'SYNCED';
ALTER TABLE reminders ADD COLUMN server_id TEXT;
ALTER TABLE reminders ADD COLUMN last_synced_at INTEGER;

-- Sync status: PENDING_CREATE, PENDING_UPDATE, PENDING_DELETE, SYNCED, CONFLICT
```

### domain/model/SyncStatus.kt
```kotlin
package com.cooleymd.reminders.domain.model

enum class SyncStatus {
    SYNCED,
    PENDING_CREATE,
    PENDING_UPDATE,
    PENDING_DELETE,
    CONFLICT
}
```

## Auth Token Storage

### data/local/AuthTokenStorage.kt
```kotlin
package com.cooleymd.reminders.data.local

import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.MutableStateFlow

// Expect/actual for platform-specific secure storage
expect class AuthTokenStorage {
    suspend fun saveTokens(accessToken: String, refreshToken: String)
    suspend fun getAccessToken(): String?
    suspend fun getRefreshToken(): String?
    suspend fun clearTokens()
    fun isLoggedIn(): Flow<Boolean>
}
```

### Android Implementation - data/local/AuthTokenStorage.android.kt
```kotlin
package com.cooleymd.reminders.data.local

import android.content.Context
import androidx.security.crypto.EncryptedSharedPreferences
import androidx.security.crypto.MasterKey
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.MutableStateFlow

actual class AuthTokenStorage(context: Context) {
    private val masterKey = MasterKey.Builder(context)
        .setKeyScheme(MasterKey.KeyScheme.AES256_GCM)
        .build()

    private val prefs = EncryptedSharedPreferences.create(
        context,
        "auth_prefs",
        masterKey,
        EncryptedSharedPreferences.PrefKeyEncryptionScheme.AES256_SIV,
        EncryptedSharedPreferences.PrefValueEncryptionScheme.AES256_GCM
    )

    private val _isLoggedIn = MutableStateFlow(getAccessToken() != null)

    actual suspend fun saveTokens(accessToken: String, refreshToken: String) {
        prefs.edit()
            .putString("access_token", accessToken)
            .putString("refresh_token", refreshToken)
            .apply()
        _isLoggedIn.value = true
    }

    actual suspend fun getAccessToken(): String? {
        return prefs.getString("access_token", null)
    }

    actual suspend fun getRefreshToken(): String? {
        return prefs.getString("refresh_token", null)
    }

    actual suspend fun clearTokens() {
        prefs.edit().clear().apply()
        _isLoggedIn.value = false
    }

    actual fun isLoggedIn(): Flow<Boolean> = _isLoggedIn
}
```

### iOS Implementation - data/local/AuthTokenStorage.ios.kt
```kotlin
package com.cooleymd.reminders.data.local

import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.MutableStateFlow
import platform.Foundation.*
import platform.Security.*

actual class AuthTokenStorage {
    private val serviceName = "com.cooleymd.reminders"
    private val _isLoggedIn = MutableStateFlow(false)

    init {
        _isLoggedIn.value = getAccessTokenSync() != null
    }

    actual suspend fun saveTokens(accessToken: String, refreshToken: String) {
        saveToKeychain("access_token", accessToken)
        saveToKeychain("refresh_token", refreshToken)
        _isLoggedIn.value = true
    }

    actual suspend fun getAccessToken(): String? {
        return getFromKeychain("access_token")
    }

    actual suspend fun getRefreshToken(): String? {
        return getFromKeychain("refresh_token")
    }

    actual suspend fun clearTokens() {
        deleteFromKeychain("access_token")
        deleteFromKeychain("refresh_token")
        _isLoggedIn.value = false
    }

    actual fun isLoggedIn(): Flow<Boolean> = _isLoggedIn

    private fun getAccessTokenSync(): String? = getFromKeychain("access_token")

    private fun saveToKeychain(key: String, value: String) {
        val query = mapOf<Any?, Any?>(
            kSecClass to kSecClassGenericPassword,
            kSecAttrService to serviceName,
            kSecAttrAccount to key,
            kSecValueData to value.encodeToByteArray().toNSData()
        ).toNSDictionary()

        SecItemDelete(query)
        SecItemAdd(query, null)
    }

    private fun getFromKeychain(key: String): String? {
        val query = mapOf<Any?, Any?>(
            kSecClass to kSecClassGenericPassword,
            kSecAttrService to serviceName,
            kSecAttrAccount to key,
            kSecReturnData to true
        ).toNSDictionary()

        val result = alloc<CFTypeRefVar>()
        return if (SecItemCopyMatching(query, result.ptr) == errSecSuccess) {
            (result.value as? NSData)?.toByteArray()?.decodeToString()
        } else null
    }

    private fun deleteFromKeychain(key: String) {
        val query = mapOf<Any?, Any?>(
            kSecClass to kSecClassGenericPassword,
            kSecAttrService to serviceName,
            kSecAttrAccount to key
        ).toNSDictionary()
        SecItemDelete(query)
    }
}
```

## Sync API Service

### data/remote/SyncApiService.kt
```kotlin
package com.cooleymd.reminders.data.remote

import com.cooleymd.reminders.data.local.AuthTokenStorage
import com.cooleymd.reminders.domain.model.Reminder
import io.ktor.client.*
import io.ktor.client.call.*
import io.ktor.client.request.*
import io.ktor.http.*
import kotlinx.datetime.Instant
import kotlinx.serialization.Serializable

class SyncApiService(
    private val client: HttpClient,
    private val authTokenStorage: AuthTokenStorage,
    private val baseUrl: String = "https://api.reminders.cooleymd.com" // Configure for environment
) {
    suspend fun uploadChanges(
        reminders: List<ReminderSyncDto>,
        lastSyncTimestamp: Instant?
    ): BatchSyncResponse {
        val accessToken = authTokenStorage.getAccessToken()
            ?: throw UnauthorizedException()

        return client.post("$baseUrl/reminders/sync") {
            header(HttpHeaders.Authorization, "Bearer $accessToken")
            contentType(ContentType.Application.Json)
            setBody(BatchSyncRequest(
                reminders = reminders,
                lastSyncTimestamp = lastSyncTimestamp
            ))
        }.body()
    }

    suspend fun getChangesSince(since: Instant): SyncResponse {
        val accessToken = authTokenStorage.getAccessToken()
            ?: throw UnauthorizedException()

        return client.get("$baseUrl/reminders/sync") {
            header(HttpHeaders.Authorization, "Bearer $accessToken")
            parameter("since", since.toString())
        }.body()
    }

    suspend fun refreshToken(): AuthResponse {
        val refreshToken = authTokenStorage.getRefreshToken()
            ?: throw UnauthorizedException()

        val response: AuthResponse = client.post("$baseUrl/auth/refresh") {
            contentType(ContentType.Application.Json)
            setBody(RefreshRequest(refreshToken))
        }.body()

        authTokenStorage.saveTokens(response.accessToken, response.refreshToken)
        return response
    }
}

@Serializable
data class ReminderSyncDto(
    val id: String,
    val title: String,
    val notes: String?,
    val scheduledAt: Instant,
    val recurrenceRule: String?, // JSON
    val status: String,
    val snoozedUntil: Instant?,
    val completedAt: Instant?,
    val labelId: String?,
    val priority: String,
    val syncStatus: String // Client sync status
)

@Serializable
data class BatchSyncRequest(
    val reminders: List<ReminderSyncDto>,
    val lastSyncTimestamp: Instant?
)

@Serializable
data class BatchSyncResponse(
    val created: List<ReminderSyncDto>,
    val updated: List<ReminderSyncDto>,
    val conflicts: List<SyncConflict>,
    val serverTimestamp: Instant
)

@Serializable
data class SyncResponse(
    val reminders: List<ReminderSyncDto>,
    val serverTimestamp: Instant
)

@Serializable
data class SyncConflict(
    val clientVersion: ReminderSyncDto,
    val serverVersion: ReminderSyncDto,
    val conflictType: String
)

@Serializable
data class RefreshRequest(val refreshToken: String)

@Serializable
data class AuthResponse(
    val accessToken: String,
    val refreshToken: String,
    val expiresIn: Long
)

class UnauthorizedException : Exception("Not authenticated")
```

## Sync Manager

### domain/sync/SyncManager.kt
```kotlin
package com.cooleymd.reminders.domain.sync

import com.cooleymd.reminders.data.local.AuthTokenStorage
import com.cooleymd.reminders.data.remote.SyncApiService
import com.cooleymd.reminders.data.remote.SyncConflict
import com.cooleymd.reminders.data.remote.UnauthorizedException
import com.cooleymd.reminders.domain.model.SyncStatus
import com.cooleymd.reminders.domain.repository.ReminderRepository
import com.cooleymd.reminders.domain.repository.SyncMetadataRepository
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.datetime.Clock
import kotlinx.datetime.Instant

class SyncManager(
    private val reminderRepository: ReminderRepository,
    private val syncApiService: SyncApiService,
    private val syncMetadataRepository: SyncMetadataRepository,
    private val authTokenStorage: AuthTokenStorage
) {
    private val _syncState = MutableStateFlow<SyncState>(SyncState.Idle)
    val syncState: StateFlow<SyncState> = _syncState

    private val _conflicts = MutableStateFlow<List<SyncConflict>>(emptyList())
    val conflicts: StateFlow<List<SyncConflict>> = _conflicts

    suspend fun sync(): SyncResult {
        if (_syncState.value is SyncState.Syncing) {
            return SyncResult.AlreadySyncing
        }

        _syncState.value = SyncState.Syncing

        return try {
            // Step 1: Get pending local changes
            val pendingChanges = reminderRepository.getPendingChanges()

            if (pendingChanges.isEmpty()) {
                // No local changes, just download
                downloadChanges()
            } else {
                // Upload local changes
                uploadChanges(pendingChanges)
            }

            _syncState.value = SyncState.Success(Clock.System.now())
            SyncResult.Success
        } catch (e: UnauthorizedException) {
            _syncState.value = SyncState.Error("Not authenticated")
            SyncResult.AuthRequired
        } catch (e: Exception) {
            _syncState.value = SyncState.Error(e.message ?: "Sync failed")
            SyncResult.Error(e)
        }
    }

    private suspend fun uploadChanges(pendingChanges: List<com.cooleymd.reminders.domain.model.Reminder>) {
        val lastSyncTimestamp = syncMetadataRepository.getLastSyncTimestamp()

        val syncDtos = pendingChanges.map { it.toSyncDto() }

        val response = syncApiService.uploadChanges(syncDtos, lastSyncTimestamp)

        // Handle conflicts
        if (response.conflicts.isNotEmpty()) {
            _conflicts.value = response.conflicts
        }

        // Mark uploaded items as synced
        response.created.forEach { dto ->
            reminderRepository.updateSyncStatus(dto.id, SyncStatus.SYNCED)
        }

        response.updated.forEach { dto ->
            reminderRepository.updateSyncStatus(dto.id, SyncStatus.SYNCED)
        }

        // Update last sync timestamp
        syncMetadataRepository.setLastSyncTimestamp(response.serverTimestamp)

        // Download any server changes
        downloadChanges()
    }

    private suspend fun downloadChanges() {
        val lastSyncTimestamp = syncMetadataRepository.getLastSyncTimestamp()
            ?: Instant.fromEpochMilliseconds(0)

        val response = syncApiService.getChangesSince(lastSyncTimestamp)

        // Apply server changes to local database
        response.reminders.forEach { serverReminder ->
            val localReminder = reminderRepository.getReminderById(serverReminder.id)

            when {
                localReminder == null -> {
                    // New from server - create locally
                    reminderRepository.insertFromServer(serverReminder)
                }
                localReminder.syncStatus == SyncStatus.SYNCED -> {
                    // No local changes - update from server
                    reminderRepository.updateFromServer(serverReminder)
                }
                else -> {
                    // Local has pending changes - conflict
                    _conflicts.value = _conflicts.value + SyncConflict(
                        clientVersion = localReminder.toSyncDto(),
                        serverVersion = serverReminder,
                        conflictType = "UPDATE_CONFLICT"
                    )
                }
            }
        }

        // Update last sync timestamp
        syncMetadataRepository.setLastSyncTimestamp(response.serverTimestamp)
    }

    fun resolveConflict(reminderId: String, resolution: ConflictResolution) {
        // Implementation for resolving conflicts
        val conflict = _conflicts.value.find { it.serverVersion.id == reminderId }
        if (conflict != null) {
            when (resolution) {
                ConflictResolution.KEEP_LOCAL -> {
                    // Mark for re-upload
                    // reminderRepository.updateSyncStatus(reminderId, SyncStatus.PENDING_UPDATE)
                }
                ConflictResolution.KEEP_SERVER -> {
                    // Apply server version
                    // reminderRepository.updateFromServer(conflict.serverVersion)
                }
                ConflictResolution.KEEP_BOTH -> {
                    // Create a copy of the local version with new ID
                    // Keep server version as-is
                }
            }
            _conflicts.value = _conflicts.value.filter { it.serverVersion.id != reminderId }
        }
    }
}

sealed class SyncState {
    object Idle : SyncState()
    object Syncing : SyncState()
    data class Success(val lastSyncTime: Instant) : SyncState()
    data class Error(val message: String) : SyncState()
}

sealed class SyncResult {
    object Success : SyncResult()
    object AlreadySyncing : SyncResult()
    object AuthRequired : SyncResult()
    data class Error(val exception: Exception) : SyncResult()
}

enum class ConflictResolution {
    KEEP_LOCAL,
    KEEP_SERVER,
    KEEP_BOTH
}
```

## Sync Metadata Repository

### domain/repository/SyncMetadataRepository.kt
```kotlin
package com.cooleymd.reminders.domain.repository

import kotlinx.datetime.Instant

interface SyncMetadataRepository {
    suspend fun getLastSyncTimestamp(): Instant?
    suspend fun setLastSyncTimestamp(timestamp: Instant)
    suspend fun getUserId(): String?
    suspend fun setUserId(userId: String)
    suspend fun clear()
}
```

## Update Reminder Repository for Sync

### Add to ReminderRepository interface
```kotlin
interface ReminderRepository {
    // ... existing methods ...

    // Sync methods
    suspend fun getPendingChanges(): List<Reminder>
    suspend fun updateSyncStatus(id: String, status: SyncStatus)
    suspend fun insertFromServer(dto: ReminderSyncDto)
    suspend fun updateFromServer(dto: ReminderSyncDto)
    suspend fun markAsDeleted(id: String) // Soft delete for sync
}
```

## Use Case Updates

### Update CreateReminderUseCase
```kotlin
class CreateReminderUseCase(
    private val repository: ReminderRepository,
    private val notificationScheduler: NotificationScheduler?
) {
    suspend operator fun invoke(/* params */): Reminder {
        val reminder = Reminder(
            // ... fields ...
            syncStatus = SyncStatus.PENDING_CREATE // Mark for sync
        )

        repository.insertReminder(reminder)
        notificationScheduler?.schedule(reminder)

        return reminder
    }
}
```

## Verification

```kotlin
// In a test or debug screen:

class SyncTestViewModel(
    private val syncManager: SyncManager
) : ViewModel() {

    val syncState = syncManager.syncState
    val conflicts = syncManager.conflicts

    fun triggerSync() {
        viewModelScope.launch {
            when (val result = syncManager.sync()) {
                is SyncResult.Success -> println("Sync successful")
                is SyncResult.AuthRequired -> println("Need to login")
                is SyncResult.Error -> println("Sync error: ${result.exception.message}")
                is SyncResult.AlreadySyncing -> println("Already syncing")
            }
        }
    }

    fun resolveConflict(reminderId: String, keepLocal: Boolean) {
        syncManager.resolveConflict(
            reminderId,
            if (keepLocal) ConflictResolution.KEEP_LOCAL else ConflictResolution.KEEP_SERVER
        )
    }
}
```

## Files to Create/Modify
- `composeApp/src/commonMain/kotlin/.../domain/model/SyncStatus.kt`
- `composeApp/src/commonMain/kotlin/.../data/local/AuthTokenStorage.kt`
- `composeApp/src/androidMain/kotlin/.../data/local/AuthTokenStorage.android.kt`
- `composeApp/src/iosMain/kotlin/.../data/local/AuthTokenStorage.ios.kt`
- `composeApp/src/commonMain/kotlin/.../data/remote/SyncApiService.kt`
- `composeApp/src/commonMain/kotlin/.../domain/sync/SyncManager.kt`
- `composeApp/src/commonMain/kotlin/.../domain/repository/SyncMetadataRepository.kt`
- Update `composeApp/src/commonMain/sqldelight/.../Reminder.sq` with sync columns
- Update `ReminderRepository.kt` with sync methods
- Update use cases to set sync status on changes
- Update `di/AppModule.kt` with sync dependencies
