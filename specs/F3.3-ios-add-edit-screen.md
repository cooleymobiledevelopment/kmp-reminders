# F3.3: iOS Add/Edit Reminder Screen

## Objective
Implement the add/edit reminder form with SwiftUI DatePicker and time selection.

## Dependencies
- F3.1 (Navigation)
- F1.4 (CRUD use cases via shared KMP module)
- F1.2 (RecurrenceRule)

## Requirements
- [ ] ViewModel/ObservableObject for add/edit with form state
- [ ] Title and notes text fields
- [ ] DatePicker for scheduled date
- [ ] TimePicker for scheduled time
- [ ] Basic recurrence selector (daily, weekly, monthly)
- [ ] Save and cancel actions
- [ ] Validation (title required, future time)
- [ ] Edit mode loads existing reminder

## ViewModel

### iosApp/Screens/Edit/AddEditReminderViewModel.swift
```swift
import Foundation
import Combine
import Shared

@MainActor
class AddEditReminderViewModel: ObservableObject {
    @Published var title: String = ""
    @Published var notes: String = ""
    @Published var scheduledDate: Date = Calendar.current.date(byAdding: .day, value: 1, to: Date()) ?? Date()
    @Published var scheduledTime: Date = Calendar.current.date(bySettingHour: 9, minute: 0, second: 0, of: Date()) ?? Date()
    @Published var recurrence: RecurrenceFrequency? = nil
    @Published var isEditMode: Bool = false
    @Published var isSaving: Bool = false
    @Published var titleError: String? = nil
    @Published var dateError: String? = nil
    @Published var error: String? = nil

    private let reminderId: String?
    private let createReminderUseCase: CreateReminderUseCase
    private let updateReminderUseCase: UpdateReminderUseCase
    private let reminderRepository: ReminderRepository

    var onSaveSuccess: (() -> Void)?

    init(
        reminderId: String?,
        createReminderUseCase: CreateReminderUseCase = KMPBridge.shared.createReminderUseCase,
        updateReminderUseCase: UpdateReminderUseCase = KMPBridge.shared.updateReminderUseCase,
        reminderRepository: ReminderRepository = KMPBridge.shared.reminderRepository
    ) {
        self.reminderId = reminderId
        self.createReminderUseCase = createReminderUseCase
        self.updateReminderUseCase = updateReminderUseCase
        self.reminderRepository = reminderRepository

        if let id = reminderId {
            loadReminder(id: id)
        }
    }

    private func loadReminder(id: String) {
        Task {
            guard let reminder = try? await reminderRepository.getReminderById(id: id) else { return }

            self.title = reminder.title
            self.notes = reminder.notes ?? ""
            self.scheduledDate = Date(timeIntervalSince1970: TimeInterval(reminder.scheduledAt.epochSeconds))
            self.scheduledTime = self.scheduledDate
            self.recurrence = reminder.recurrenceRule?.frequency.toSwift()
            self.isEditMode = true
        }
    }

    func onTitleChange(_ newTitle: String) {
        title = newTitle
        titleError = nil
    }

    func onNotesChange(_ newNotes: String) {
        notes = newNotes
    }

    func onDateChange(_ newDate: Date) {
        scheduledDate = newDate
        dateError = nil
    }

    func onTimeChange(_ newTime: Date) {
        scheduledTime = newTime
    }

    func onRecurrenceChange(_ frequency: RecurrenceFrequency?) {
        recurrence = frequency
    }

    func onSave() {
        // Validate
        if title.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty {
            titleError = "Title is required"
            return
        }

        let combinedDateTime = combineDateTime(date: scheduledDate, time: scheduledTime)
        if combinedDateTime <= Date() {
            dateError = "Must be in the future"
            return
        }

        isSaving = true

        Task {
            do {
                let scheduledAtInstant = Kotlinx_datetimeInstant.companion.fromEpochSeconds(
                    epochSeconds: Int64(combinedDateTime.timeIntervalSince1970),
                    nanosecondAdjustment: 0
                )

                let recurrenceRule: RecurrenceRule? = recurrence.map { freq in
                    RecurrenceRule(frequency: freq.toKotlin())
                }

                if isEditMode, let id = reminderId {
                    // Update existing
                    guard let existing = try await reminderRepository.getReminderById(id: id) else {
                        throw NSError(domain: "Reminder not found", code: 404)
                    }

                    let updated = existing.doCopy(
                        id: existing.id,
                        title: title,
                        notes: notes.isEmpty ? nil : notes,
                        scheduledAt: scheduledAtInstant,
                        recurrenceRule: recurrenceRule,
                        status: existing.status,
                        snoozedUntil: existing.snoozedUntil,
                        completedAt: existing.completedAt,
                        labelId: existing.labelId,
                        priority: existing.priority,
                        createdAt: existing.createdAt,
                        updatedAt: Kotlinx_datetimeClock.System.shared.now()
                    )

                    try await updateReminderUseCase.invoke(reminder: updated)
                } else {
                    // Create new
                    try await createReminderUseCase.invoke(
                        title: title,
                        notes: notes.isEmpty ? nil : notes,
                        scheduledAt: scheduledAtInstant,
                        recurrenceRule: recurrenceRule
                    )
                }

                isSaving = false
                onSaveSuccess?()
            } catch {
                self.error = error.localizedDescription
                isSaving = false
            }
        }
    }

    private func combineDateTime(date: Date, time: Date) -> Date {
        let calendar = Calendar.current
        let dateComponents = calendar.dateComponents([.year, .month, .day], from: date)
        let timeComponents = calendar.dateComponents([.hour, .minute], from: time)

        var combined = DateComponents()
        combined.year = dateComponents.year
        combined.month = dateComponents.month
        combined.day = dateComponents.day
        combined.hour = timeComponents.hour
        combined.minute = timeComponents.minute

        return calendar.date(from: combined) ?? date
    }
}

enum RecurrenceFrequency: String, CaseIterable, Identifiable {
    case daily = "Daily"
    case weekly = "Weekly"
    case monthly = "Monthly"

    var id: String { rawValue }

    func toKotlin() -> Frequency {
        switch self {
        case .daily: return .daily
        case .weekly: return .weekly
        case .monthly: return .monthly
        }
    }
}

extension Frequency {
    func toSwift() -> RecurrenceFrequency {
        switch self {
        case .daily: return .daily
        case .weekly: return .weekly
        case .monthly: return .monthly
        default: return .daily
        }
    }
}
```

## Screen UI

### iosApp/Screens/Edit/AddEditReminderScreen.swift
```swift
import SwiftUI
import Shared

struct AddEditReminderScreen: View {
    @StateObject private var viewModel: AddEditReminderViewModel
    let onDismiss: () -> Void

    init(reminderId: String?, onDismiss: @escaping () -> Void) {
        _viewModel = StateObject(wrappedValue: AddEditReminderViewModel(reminderId: reminderId))
        self.onDismiss = onDismiss
    }

    var body: some View {
        Form {
            Section {
                TextField("Title", text: $viewModel.title)
                    .onChange(of: viewModel.title) { newValue in
                        viewModel.onTitleChange(newValue)
                    }

                if let titleError = viewModel.titleError {
                    Text(titleError)
                        .font(.caption)
                        .foregroundColor(.red)
                }
            }

            Section {
                TextField("Notes (optional)", text: $viewModel.notes, axis: .vertical)
                    .lineLimit(3...6)
                    .onChange(of: viewModel.notes) { newValue in
                        viewModel.onNotesChange(newValue)
                    }
            }

            Section("Schedule") {
                DatePicker(
                    "Date",
                    selection: $viewModel.scheduledDate,
                    in: Date()...,
                    displayedComponents: .date
                )
                .onChange(of: viewModel.scheduledDate) { newValue in
                    viewModel.onDateChange(newValue)
                }

                DatePicker(
                    "Time",
                    selection: $viewModel.scheduledTime,
                    displayedComponents: .hourAndMinute
                )
                .onChange(of: viewModel.scheduledTime) { newValue in
                    viewModel.onTimeChange(newValue)
                }

                if let dateError = viewModel.dateError {
                    Text(dateError)
                        .font(.caption)
                        .foregroundColor(.red)
                }
            }

            Section("Repeat") {
                Picker("Recurrence", selection: $viewModel.recurrence) {
                    Text("Never").tag(nil as RecurrenceFrequency?)
                    ForEach(RecurrenceFrequency.allCases) { frequency in
                        Text(frequency.rawValue).tag(frequency as RecurrenceFrequency?)
                    }
                }
                .onChange(of: viewModel.recurrence) { newValue in
                    viewModel.onRecurrenceChange(newValue)
                }
            }

            if let error = viewModel.error {
                Section {
                    Text(error)
                        .foregroundColor(.red)
                }
            }
        }
        .navigationTitle(viewModel.isEditMode ? "Edit Reminder" : "New Reminder")
        .navigationBarTitleDisplayMode(.inline)
        .toolbar {
            ToolbarItem(placement: .cancellationAction) {
                Button("Cancel", action: onDismiss)
            }

            ToolbarItem(placement: .confirmationAction) {
                Button("Save") {
                    viewModel.onSave()
                }
                .disabled(viewModel.isSaving)
            }
        }
        .onAppear {
            viewModel.onSaveSuccess = onDismiss
        }
        .interactiveDismissDisabled(viewModel.isSaving)
    }
}
```

## Preview Provider

### iosApp/Screens/Edit/AddEditReminderScreen+Preview.swift
```swift
import SwiftUI

#Preview("Add Mode") {
    NavigationStack {
        AddEditReminderScreen(reminderId: nil, onDismiss: {})
    }
}

#Preview("Edit Mode") {
    NavigationStack {
        AddEditReminderScreen(reminderId: "preview-id", onDismiss: {})
    }
}
```

## Verification
```bash
# Open iosApp in Xcode and run
# Create reminder with all fields
# Edit existing reminder
# Validation shows errors for empty title
# Validation shows error for past date
# Save navigates back to home
# Cancel navigates back without saving
```

## Files to Create
- `iosApp/iosApp/Screens/Edit/AddEditReminderViewModel.swift`
- `iosApp/iosApp/Screens/Edit/AddEditReminderScreen.swift`
- Update `iosApp/iosApp/KMP/KMPBridge.swift` to expose createReminderUseCase and updateReminderUseCase
