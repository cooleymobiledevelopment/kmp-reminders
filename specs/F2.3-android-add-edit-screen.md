# F2.3: Android Add/Edit Reminder Screen

## Objective
Implement the add/edit reminder form with date/time pickers.

## Dependencies
- F2.1 (Navigation)
- F1.4 (CRUD use cases)
- F1.2 (RecurrenceRule)

## Requirements
- [ ] ViewModel for add/edit with form state
- [ ] Title and notes text fields
- [ ] Date picker for scheduled date
- [ ] Time picker for scheduled time
- [ ] Basic recurrence selector (daily, weekly, monthly)
- [ ] Save and cancel actions
- [ ] Validation (title required, future time)
- [ ] Edit mode loads existing reminder

## ViewModel

### presentation/edit/AddEditReminderViewModel.kt
```kotlin
class AddEditReminderViewModel(
    private val reminderId: String?,
    private val createReminderUseCase: CreateReminderUseCase,
    private val updateReminderUseCase: UpdateReminderUseCase,
    private val reminderRepository: ReminderRepository
) : ViewModel() {

    private val _uiState = MutableStateFlow(AddEditUiState())
    val uiState: StateFlow<AddEditUiState> = _uiState.asStateFlow()

    private val _events = Channel<AddEditEvent>()
    val events = _events.receiveAsFlow()

    init {
        if (reminderId != null) {
            loadReminder(reminderId)
        }
    }

    private fun loadReminder(id: String) {
        viewModelScope.launch {
            val reminder = reminderRepository.getReminderById(id)
            if (reminder != null) {
                _uiState.update {
                    it.copy(
                        title = reminder.title,
                        notes = reminder.notes ?: "",
                        scheduledDate = reminder.scheduledAt.toLocalDate(),
                        scheduledTime = reminder.scheduledAt.toLocalTime(),
                        recurrence = reminder.recurrenceRule?.frequency,
                        isEditMode = true
                    )
                }
            }
        }
    }

    fun onTitleChange(title: String) {
        _uiState.update { it.copy(title = title, titleError = null) }
    }

    fun onNotesChange(notes: String) {
        _uiState.update { it.copy(notes = notes) }
    }

    fun onDateChange(date: LocalDate) {
        _uiState.update { it.copy(scheduledDate = date, dateError = null) }
    }

    fun onTimeChange(time: LocalTime) {
        _uiState.update { it.copy(scheduledTime = time) }
    }

    fun onRecurrenceChange(frequency: Frequency?) {
        _uiState.update { it.copy(recurrence = frequency) }
    }

    fun onSave() {
        val state = _uiState.value

        // Validate
        if (state.title.isBlank()) {
            _uiState.update { it.copy(titleError = "Title is required") }
            return
        }

        val scheduledAt = state.scheduledDate.atTime(state.scheduledTime).toInstant()
        if (scheduledAt <= Clock.System.now()) {
            _uiState.update { it.copy(dateError = "Must be in the future") }
            return
        }

        viewModelScope.launch {
            try {
                _uiState.update { it.copy(isSaving = true) }

                val recurrenceRule = state.recurrence?.let {
                    RecurrenceRule(frequency = it)
                }

                if (state.isEditMode && reminderId != null) {
                    // Update
                    val existing = reminderRepository.getReminderById(reminderId)!!
                    updateReminderUseCase(
                        existing.copy(
                            title = state.title,
                            notes = state.notes.ifBlank { null },
                            scheduledAt = scheduledAt,
                            recurrenceRule = recurrenceRule
                        )
                    )
                } else {
                    // Create
                    createReminderUseCase(
                        title = state.title,
                        notes = state.notes.ifBlank { null },
                        scheduledAt = scheduledAt,
                        recurrenceRule = recurrenceRule
                    )
                }

                _events.send(AddEditEvent.SaveSuccess)
            } catch (e: Exception) {
                _uiState.update { it.copy(error = e.message, isSaving = false) }
            }
        }
    }
}

data class AddEditUiState(
    val title: String = "",
    val notes: String = "",
    val scheduledDate: LocalDate = Clock.System.now().toLocalDate().plus(1, DateTimeUnit.DAY),
    val scheduledTime: LocalTime = LocalTime(9, 0),
    val recurrence: Frequency? = null,
    val isEditMode: Boolean = false,
    val isSaving: Boolean = false,
    val titleError: String? = null,
    val dateError: String? = null,
    val error: String? = null
)

sealed class AddEditEvent {
    object SaveSuccess : AddEditEvent()
}
```

## Screen UI

### presentation/edit/AddEditReminderScreen.kt
```kotlin
@Composable
fun AddEditReminderScreen(
    reminderId: String?,
    onNavigateBack: () -> Unit,
    viewModel: AddEditReminderViewModel = koinViewModel { parametersOf(reminderId) }
) {
    val uiState by viewModel.uiState.collectAsState()

    LaunchedEffect(Unit) {
        viewModel.events.collect { event ->
            when (event) {
                AddEditEvent.SaveSuccess -> onNavigateBack()
            }
        }
    }

    Scaffold(
        topBar = {
            TopAppBar(
                title = { Text(if (uiState.isEditMode) "Edit Reminder" else "New Reminder") },
                navigationIcon = {
                    IconButton(onClick = onNavigateBack) {
                        Icon(Icons.Default.Close, "Cancel")
                    }
                },
                actions = {
                    TextButton(
                        onClick = { viewModel.onSave() },
                        enabled = !uiState.isSaving
                    ) {
                        Text("Save")
                    }
                }
            )
        }
    ) { padding ->
        Column(
            modifier = Modifier
                .padding(padding)
                .padding(16.dp)
                .verticalScroll(rememberScrollState())
        ) {
            OutlinedTextField(
                value = uiState.title,
                onValueChange = { viewModel.onTitleChange(it) },
                label = { Text("Title") },
                isError = uiState.titleError != null,
                supportingText = uiState.titleError?.let { { Text(it) } },
                modifier = Modifier.fillMaxWidth()
            )

            Spacer(Modifier.height(16.dp))

            OutlinedTextField(
                value = uiState.notes,
                onValueChange = { viewModel.onNotesChange(it) },
                label = { Text("Notes (optional)") },
                minLines = 3,
                modifier = Modifier.fillMaxWidth()
            )

            Spacer(Modifier.height(16.dp))

            DatePickerField(
                date = uiState.scheduledDate,
                onDateChange = { viewModel.onDateChange(it) },
                error = uiState.dateError
            )

            Spacer(Modifier.height(16.dp))

            TimePickerField(
                time = uiState.scheduledTime,
                onTimeChange = { viewModel.onTimeChange(it) }
            )

            Spacer(Modifier.height(16.dp))

            RecurrenceSelector(
                selected = uiState.recurrence,
                onSelect = { viewModel.onRecurrenceChange(it) }
            )
        }
    }
}
```

## Picker Components

Create reusable date/time picker components using Material3 dialogs.

## Verification
```bash
./gradlew :composeApp:installDebug
# Create reminder with all fields
# Edit existing reminder
# Validation shows errors
```

## Files to Create
- `composeApp/src/androidMain/kotlin/.../presentation/edit/AddEditReminderViewModel.kt`
- `composeApp/src/androidMain/kotlin/.../presentation/edit/AddEditUiState.kt`
- `composeApp/src/androidMain/kotlin/.../presentation/edit/AddEditReminderScreen.kt`
- `composeApp/src/androidMain/kotlin/.../presentation/edit/DatePickerField.kt`
- `composeApp/src/androidMain/kotlin/.../presentation/edit/TimePickerField.kt`
- `composeApp/src/androidMain/kotlin/.../presentation/edit/RecurrenceSelector.kt`
- Update `di/AppModule.kt`
