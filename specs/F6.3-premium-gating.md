# F6.3: Premium Feature Gating

## Objective
Implement feature gates to differentiate free vs premium experiences.

## Dependencies
- F6.1 (RevenueCat setup)
- F6.2 (Paywall)

## Requirements
- [ ] Define free tier limits
- [ ] Gate reminder creation at limit
- [ ] Gate cloud sync behind premium
- [ ] Gate label creation at limit
- [ ] Show upgrade prompts at gate points
- [ ] Graceful degradation for expired subscriptions
- [ ] Premium badge/indicator in UI

## Feature Limits Configuration

### domain/premium/PremiumConfig.kt
```kotlin
package com.cooleymd.reminders.domain.premium

object PremiumConfig {
    // Free tier limits
    const val FREE_REMINDER_LIMIT = 10
    const val FREE_LABEL_LIMIT = 3

    // Premium features
    val PREMIUM_FEATURES = setOf(
        Feature.UNLIMITED_REMINDERS,
        Feature.UNLIMITED_LABELS,
        Feature.CLOUD_SYNC,
        Feature.PRIORITY_SUPPORT,
        Feature.CUSTOM_THEMES
    )

    enum class Feature {
        UNLIMITED_REMINDERS,
        UNLIMITED_LABELS,
        CLOUD_SYNC,
        PRIORITY_SUPPORT,
        CUSTOM_THEMES
    }
}
```

## Feature Gate Service

### domain/premium/FeatureGate.kt
```kotlin
package com.cooleymd.reminders.domain.premium

import com.cooleymd.reminders.domain.purchase.PurchaseManager
import com.cooleymd.reminders.domain.repository.ReminderRepository
import com.cooleymd.reminders.domain.repository.LabelRepository
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.combine
import kotlinx.coroutines.flow.first

class FeatureGate(
    private val purchaseManager: PurchaseManager,
    private val reminderRepository: ReminderRepository,
    private val labelRepository: LabelRepository
) {
    val isPremium: Flow<Boolean> = purchaseManager.isPremium

    suspend fun canCreateReminder(): GateResult {
        if (purchaseManager.isPremium.value) {
            return GateResult.Allowed
        }

        val currentCount = reminderRepository.getAllReminders().first().size
        return if (currentCount < PremiumConfig.FREE_REMINDER_LIMIT) {
            GateResult.Allowed
        } else {
            GateResult.Blocked(
                reason = BlockedReason.REMINDER_LIMIT,
                message = "You've reached the limit of ${PremiumConfig.FREE_REMINDER_LIMIT} reminders. Upgrade to Premium for unlimited reminders."
            )
        }
    }

    suspend fun canCreateLabel(): GateResult {
        if (purchaseManager.isPremium.value) {
            return GateResult.Allowed
        }

        val currentCount = labelRepository.getAllLabels().first().size
        return if (currentCount < PremiumConfig.FREE_LABEL_LIMIT) {
            GateResult.Allowed
        } else {
            GateResult.Blocked(
                reason = BlockedReason.LABEL_LIMIT,
                message = "You've reached the limit of ${PremiumConfig.FREE_LABEL_LIMIT} labels. Upgrade to Premium for unlimited labels."
            )
        }
    }

    fun canUseCloudSync(): GateResult {
        return if (purchaseManager.isPremium.value) {
            GateResult.Allowed
        } else {
            GateResult.Blocked(
                reason = BlockedReason.PREMIUM_FEATURE,
                message = "Cloud sync is a Premium feature. Upgrade to sync your reminders across devices."
            )
        }
    }

    fun canUseCustomThemes(): GateResult {
        return if (purchaseManager.isPremium.value) {
            GateResult.Allowed
        } else {
            GateResult.Blocked(
                reason = BlockedReason.PREMIUM_FEATURE,
                message = "Custom themes are a Premium feature."
            )
        }
    }

    fun getRemainingFreeReminders(): Flow<Int> {
        return combine(
            purchaseManager.isPremium,
            reminderRepository.getAllReminders()
        ) { isPremium, reminders ->
            if (isPremium) {
                Int.MAX_VALUE
            } else {
                (PremiumConfig.FREE_REMINDER_LIMIT - reminders.size).coerceAtLeast(0)
            }
        }
    }

    fun getRemainingFreeLabels(): Flow<Int> {
        return combine(
            purchaseManager.isPremium,
            labelRepository.getAllLabels()
        ) { isPremium, labels ->
            if (isPremium) {
                Int.MAX_VALUE
            } else {
                (PremiumConfig.FREE_LABEL_LIMIT - labels.size).coerceAtLeast(0)
            }
        }
    }
}

sealed class GateResult {
    object Allowed : GateResult()
    data class Blocked(
        val reason: BlockedReason,
        val message: String
    ) : GateResult()
}

enum class BlockedReason {
    REMINDER_LIMIT,
    LABEL_LIMIT,
    PREMIUM_FEATURE,
    SUBSCRIPTION_EXPIRED
}
```

## Gated Use Cases

### domain/usecase/CreateReminderUseCase.kt (Updated)
```kotlin
class CreateReminderUseCase(
    private val repository: ReminderRepository,
    private val featureGate: FeatureGate,
    private val notificationScheduler: NotificationScheduler?
) {
    suspend operator fun invoke(
        title: String,
        notes: String?,
        scheduledAt: Instant,
        recurrenceRule: RecurrenceRule?
    ): CreateReminderResult {
        // Check feature gate
        return when (val gateResult = featureGate.canCreateReminder()) {
            is GateResult.Allowed -> {
                val reminder = Reminder(
                    id = UUID.randomUUID().toString(),
                    title = title,
                    notes = notes,
                    scheduledAt = scheduledAt,
                    recurrenceRule = recurrenceRule,
                    createdAt = Clock.System.now(),
                    updatedAt = Clock.System.now(),
                    syncStatus = SyncStatus.PENDING_CREATE
                )

                repository.insertReminder(reminder)
                notificationScheduler?.schedule(reminder)

                CreateReminderResult.Success(reminder)
            }
            is GateResult.Blocked -> {
                CreateReminderResult.LimitReached(gateResult.message)
            }
        }
    }
}

sealed class CreateReminderResult {
    data class Success(val reminder: Reminder) : CreateReminderResult()
    data class LimitReached(val message: String) : CreateReminderResult()
}
```

## Premium Badge Component

### presentation/components/PremiumBadge.kt
```kotlin
@Composable
fun PremiumBadge(
    modifier: Modifier = Modifier
) {
    Surface(
        color = MaterialTheme.colorScheme.primaryContainer,
        shape = RoundedCornerShape(4.dp),
        modifier = modifier
    ) {
        Row(
            modifier = Modifier.padding(horizontal = 8.dp, vertical = 4.dp),
            verticalAlignment = Alignment.CenterVertically,
            horizontalArrangement = Arrangement.spacedBy(4.dp)
        ) {
            Icon(
                imageVector = Icons.Default.Star,
                contentDescription = null,
                modifier = Modifier.size(12.dp),
                tint = MaterialTheme.colorScheme.primary
            )
            Text(
                text = "PREMIUM",
                style = MaterialTheme.typography.labelSmall,
                fontWeight = FontWeight.Bold,
                color = MaterialTheme.colorScheme.primary
            )
        }
    }
}
```

## Feature Lock Indicator

### presentation/components/FeatureLockOverlay.kt
```kotlin
@Composable
fun FeatureLockOverlay(
    isLocked: Boolean,
    onUnlockClick: () -> Unit,
    content: @Composable () -> Unit
) {
    Box {
        content()

        if (isLocked) {
            Box(
                modifier = Modifier
                    .matchParentSize()
                    .background(MaterialTheme.colorScheme.surface.copy(alpha = 0.8f))
                    .clickable(onClick = onUnlockClick),
                contentAlignment = Alignment.Center
            ) {
                Column(
                    horizontalAlignment = Alignment.CenterHorizontally
                ) {
                    Icon(
                        imageVector = Icons.Default.Lock,
                        contentDescription = "Locked",
                        tint = MaterialTheme.colorScheme.primary
                    )
                    Spacer(Modifier.height(8.dp))
                    Text(
                        text = "Premium Feature",
                        style = MaterialTheme.typography.labelMedium
                    )
                    TextButton(onClick = onUnlockClick) {
                        Text("Unlock")
                    }
                }
            }
        }
    }
}
```

## Remaining Quota Indicator

### presentation/components/QuotaIndicator.kt
```kotlin
@Composable
fun QuotaIndicator(
    current: Int,
    max: Int,
    label: String,
    onUpgradeClick: () -> Unit,
    modifier: Modifier = Modifier
) {
    val progress = (current.toFloat() / max.toFloat()).coerceIn(0f, 1f)
    val isNearLimit = current >= max - 2
    val isAtLimit = current >= max

    Card(
        modifier = modifier.fillMaxWidth(),
        colors = CardDefaults.cardColors(
            containerColor = if (isAtLimit) {
                MaterialTheme.colorScheme.errorContainer
            } else if (isNearLimit) {
                MaterialTheme.colorScheme.tertiaryContainer
            } else {
                MaterialTheme.colorScheme.surfaceVariant
            }
        )
    ) {
        Column(
            modifier = Modifier.padding(16.dp)
        ) {
            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.SpaceBetween
            ) {
                Text(
                    text = label,
                    style = MaterialTheme.typography.labelMedium
                )
                Text(
                    text = "$current / $max",
                    style = MaterialTheme.typography.labelMedium,
                    fontWeight = FontWeight.Bold
                )
            }

            Spacer(Modifier.height(8.dp))

            LinearProgressIndicator(
                progress = { progress },
                modifier = Modifier.fillMaxWidth(),
                color = if (isAtLimit) {
                    MaterialTheme.colorScheme.error
                } else {
                    MaterialTheme.colorScheme.primary
                }
            )

            if (isAtLimit) {
                Spacer(Modifier.height(8.dp))
                TextButton(
                    onClick = onUpgradeClick,
                    modifier = Modifier.align(Alignment.End)
                ) {
                    Text("Upgrade for Unlimited")
                }
            }
        }
    }
}
```

## Settings Screen with Premium Status

### presentation/settings/SettingsScreen.kt
```kotlin
@Composable
fun SettingsScreen(
    viewModel: SettingsViewModel = koinViewModel(),
    onNavigateToPaywall: () -> Unit
) {
    val isPremium by viewModel.isPremium.collectAsState()
    val remainingReminders by viewModel.remainingReminders.collectAsState(initial = 0)
    val remainingLabels by viewModel.remainingLabels.collectAsState(initial = 0)

    Scaffold(
        topBar = {
            TopAppBar(
                title = { Text("Settings") }
            )
        }
    ) { padding ->
        LazyColumn(
            modifier = Modifier
                .fillMaxSize()
                .padding(padding)
        ) {
            // Premium status section
            item {
                if (isPremium) {
                    PremiumStatusCard()
                } else {
                    FreeStatusCard(
                        remainingReminders = remainingReminders,
                        remainingLabels = remainingLabels,
                        onUpgradeClick = onNavigateToPaywall
                    )
                }
            }

            // Account section
            item {
                SettingsSection(title = "Account") {
                    SettingsItem(
                        title = "Sync",
                        subtitle = if (isPremium) "Enabled" else "Premium feature",
                        icon = Icons.Default.Sync,
                        locked = !isPremium,
                        onClick = { if (!isPremium) onNavigateToPaywall() }
                    )
                }
            }

            // Appearance section
            item {
                SettingsSection(title = "Appearance") {
                    SettingsItem(
                        title = "Theme",
                        subtitle = if (isPremium) "Light / Dark / System" else "Premium feature",
                        icon = Icons.Default.Palette,
                        locked = !isPremium,
                        onClick = { if (!isPremium) onNavigateToPaywall() }
                    )
                }
            }

            // About section
            item {
                SettingsSection(title = "About") {
                    SettingsItem(
                        title = "Restore Purchases",
                        icon = Icons.Default.Restore,
                        onClick = { viewModel.restorePurchases() }
                    )
                    SettingsItem(
                        title = "Privacy Policy",
                        icon = Icons.Default.PrivacyTip,
                        onClick = { /* Open URL */ }
                    )
                    SettingsItem(
                        title = "Terms of Service",
                        icon = Icons.Default.Description,
                        onClick = { /* Open URL */ }
                    )
                }
            }
        }
    }
}

@Composable
fun PremiumStatusCard() {
    Card(
        modifier = Modifier
            .fillMaxWidth()
            .padding(16.dp),
        colors = CardDefaults.cardColors(
            containerColor = MaterialTheme.colorScheme.primaryContainer
        )
    ) {
        Row(
            modifier = Modifier
                .padding(16.dp)
                .fillMaxWidth(),
            verticalAlignment = Alignment.CenterVertically
        ) {
            Icon(
                imageVector = Icons.Default.Star,
                contentDescription = null,
                tint = MaterialTheme.colorScheme.primary,
                modifier = Modifier.size(40.dp)
            )
            Spacer(Modifier.width(16.dp))
            Column {
                Text(
                    text = "Premium Member",
                    style = MaterialTheme.typography.titleMedium,
                    fontWeight = FontWeight.Bold
                )
                Text(
                    text = "All features unlocked",
                    style = MaterialTheme.typography.bodySmall
                )
            }
        }
    }
}

@Composable
fun FreeStatusCard(
    remainingReminders: Int,
    remainingLabels: Int,
    onUpgradeClick: () -> Unit
) {
    Card(
        modifier = Modifier
            .fillMaxWidth()
            .padding(16.dp)
    ) {
        Column(
            modifier = Modifier.padding(16.dp)
        ) {
            Text(
                text = "Free Plan",
                style = MaterialTheme.typography.titleMedium,
                fontWeight = FontWeight.Bold
            )

            Spacer(Modifier.height(16.dp))

            QuotaIndicator(
                current = PremiumConfig.FREE_REMINDER_LIMIT - remainingReminders,
                max = PremiumConfig.FREE_REMINDER_LIMIT,
                label = "Reminders",
                onUpgradeClick = onUpgradeClick
            )

            Spacer(Modifier.height(8.dp))

            QuotaIndicator(
                current = PremiumConfig.FREE_LABEL_LIMIT - remainingLabels,
                max = PremiumConfig.FREE_LABEL_LIMIT,
                label = "Labels",
                onUpgradeClick = onUpgradeClick
            )

            Spacer(Modifier.height(16.dp))

            Button(
                onClick = onUpgradeClick,
                modifier = Modifier.fillMaxWidth()
            ) {
                Text("Upgrade to Premium")
            }
        }
    }
}
```

## iOS Premium Gating

### iosApp/Premium/FeatureGate.swift
```swift
import Foundation
import Combine

@MainActor
class FeatureGate: ObservableObject {
    @Published var isPremium: Bool = false
    @Published var remainingReminders: Int = PremiumConfig.freeReminderLimit
    @Published var remainingLabels: Int = PremiumConfig.freeLabelLimit

    private let purchaseManager: IOSPurchaseManager
    private var cancellables = Set<AnyCancellable>()

    init(purchaseManager: IOSPurchaseManager = .shared) {
        self.purchaseManager = purchaseManager

        purchaseManager.$isPremium
            .assign(to: &$isPremium)
    }

    func canCreateReminder(currentCount: Int) -> GateResult {
        if isPremium {
            return .allowed
        }

        if currentCount < PremiumConfig.freeReminderLimit {
            return .allowed
        }

        return .blocked(
            reason: .reminderLimit,
            message: "You've reached the limit of \(PremiumConfig.freeReminderLimit) reminders."
        )
    }

    func canCreateLabel(currentCount: Int) -> GateResult {
        if isPremium {
            return .allowed
        }

        if currentCount < PremiumConfig.freeLabelLimit {
            return .allowed
        }

        return .blocked(
            reason: .labelLimit,
            message: "You've reached the limit of \(PremiumConfig.freeLabelLimit) labels."
        )
    }

    func canUseCloudSync() -> GateResult {
        if isPremium {
            return .allowed
        }

        return .blocked(
            reason: .premiumFeature,
            message: "Cloud sync is a Premium feature."
        )
    }
}

enum GateResult {
    case allowed
    case blocked(reason: BlockedReason, message: String)
}

enum BlockedReason {
    case reminderLimit
    case labelLimit
    case premiumFeature
    case subscriptionExpired
}

enum PremiumConfig {
    static let freeReminderLimit = 10
    static let freeLabelLimit = 3
}
```

## Verification

```kotlin
// Test feature gating

@Test
fun `free user blocked at reminder limit`() = runTest {
    // Create max free reminders
    repeat(PremiumConfig.FREE_REMINDER_LIMIT) {
        repository.insertReminder(createTestReminder())
    }

    val result = createReminderUseCase("New reminder", ...)

    assertTrue(result is CreateReminderResult.LimitReached)
}

@Test
fun `premium user not blocked`() = runTest {
    purchaseManager.setPremium(true)

    // Create more than free limit
    repeat(PremiumConfig.FREE_REMINDER_LIMIT + 5) {
        val result = createReminderUseCase("Reminder $it", ...)
        assertTrue(result is CreateReminderResult.Success)
    }
}

@Test
fun `sync blocked for free user`() {
    purchaseManager.setPremium(false)

    val result = featureGate.canUseCloudSync()

    assertTrue(result is GateResult.Blocked)
}
```

## Files to Create/Modify
- `composeApp/src/commonMain/kotlin/.../domain/premium/PremiumConfig.kt`
- `composeApp/src/commonMain/kotlin/.../domain/premium/FeatureGate.kt`
- Update `CreateReminderUseCase.kt` with gating
- Update `CreateLabelUseCase.kt` with gating
- `composeApp/src/androidMain/kotlin/.../presentation/components/PremiumBadge.kt`
- `composeApp/src/androidMain/kotlin/.../presentation/components/FeatureLockOverlay.kt`
- `composeApp/src/androidMain/kotlin/.../presentation/components/QuotaIndicator.kt`
- `composeApp/src/androidMain/kotlin/.../presentation/settings/SettingsScreen.kt`
- `iosApp/iosApp/Premium/FeatureGate.swift`
- `iosApp/iosApp/Components/PremiumBadge.swift`
- `iosApp/iosApp/Screens/Settings/SettingsScreen.swift`
- Update `di/AppModule.kt` with FeatureGate
