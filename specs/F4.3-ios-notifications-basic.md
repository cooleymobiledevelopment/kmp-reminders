# F4.3: iOS Basic Notifications

## Objective
Set up UNUserNotificationCenter and schedule local notifications for reminders on iOS.

## Dependencies
- F1.1 (Reminder model)
- F3.3 (Add/Edit screen - for triggering notification scheduling)

## Requirements
- [ ] Request notification permissions
- [ ] UNUserNotificationCenter setup
- [ ] Schedule notifications when reminder is created/updated
- [ ] Cancel notifications when reminder is deleted/completed
- [ ] Handle notification tap to open specific reminder
- [ ] Support notification content (title, body, sound)

## Notification Manager

### iosApp/Notifications/NotificationManager.swift
```swift
import Foundation
import UserNotifications
import Shared

class NotificationManager: NSObject, ObservableObject {
    static let shared = NotificationManager()

    @Published var isAuthorized: Bool = false

    private let notificationCenter = UNUserNotificationCenter.current()

    override private init() {
        super.init()
        notificationCenter.delegate = self
        checkAuthorizationStatus()
    }

    // MARK: - Authorization

    func requestAuthorization() async -> Bool {
        do {
            let granted = try await notificationCenter.requestAuthorization(
                options: [.alert, .sound, .badge]
            )
            await MainActor.run {
                self.isAuthorized = granted
            }
            return granted
        } catch {
            print("Notification authorization error: \(error)")
            return false
        }
    }

    func checkAuthorizationStatus() {
        notificationCenter.getNotificationSettings { settings in
            DispatchQueue.main.async {
                self.isAuthorized = settings.authorizationStatus == .authorized
            }
        }
    }

    // MARK: - Scheduling

    func scheduleNotification(for reminder: Reminder) {
        // Cancel any existing notification for this reminder
        cancelNotification(for: reminder.id)

        let content = UNMutableNotificationContent()
        content.title = reminder.title
        content.body = reminder.notes ?? "Time for your reminder!"
        content.sound = .default
        content.badge = 1
        content.userInfo = ["reminderId": reminder.id]
        content.categoryIdentifier = ReminderNotificationCategory.identifier

        // Convert Kotlin Instant to Date
        let triggerDate = Date(timeIntervalSince1970: TimeInterval(reminder.scheduledAt.epochSeconds))

        // Don't schedule if the date is in the past
        guard triggerDate > Date() else { return }

        let components = Calendar.current.dateComponents(
            [.year, .month, .day, .hour, .minute, .second],
            from: triggerDate
        )

        let trigger = UNCalendarNotificationTrigger(
            dateMatching: components,
            repeats: false
        )

        let request = UNNotificationRequest(
            identifier: reminder.id,
            content: content,
            trigger: trigger
        )

        notificationCenter.add(request) { error in
            if let error = error {
                print("Failed to schedule notification: \(error)")
            }
        }
    }

    func cancelNotification(for reminderId: String) {
        notificationCenter.removePendingNotificationRequests(withIdentifiers: [reminderId])
        notificationCenter.removeDeliveredNotifications(withIdentifiers: [reminderId])
    }

    func cancelAllNotifications() {
        notificationCenter.removeAllPendingNotificationRequests()
        notificationCenter.removeAllDeliveredNotifications()
    }

    // MARK: - Pending Notifications

    func getPendingNotificationIds() async -> [String] {
        let requests = await notificationCenter.pendingNotificationRequests()
        return requests.map { $0.identifier }
    }

    func rescheduleAllReminders(reminders: [Reminder]) {
        let now = Date()

        for reminder in reminders {
            let scheduledDate = Date(timeIntervalSince1970: TimeInterval(reminder.scheduledAt.epochSeconds))

            // Only schedule pending reminders in the future
            if reminder.status == .pending && scheduledDate > now {
                scheduleNotification(for: reminder)
            }
        }
    }
}

// MARK: - UNUserNotificationCenterDelegate

extension NotificationManager: UNUserNotificationCenterDelegate {
    // Handle notification when app is in foreground
    func userNotificationCenter(
        _ center: UNUserNotificationCenter,
        willPresent notification: UNNotification,
        withCompletionHandler completionHandler: @escaping (UNNotificationPresentationOptions) -> Void
    ) {
        // Show notification even when app is in foreground
        completionHandler([.banner, .sound, .badge])
    }

    // Handle notification tap
    func userNotificationCenter(
        _ center: UNUserNotificationCenter,
        didReceive response: UNNotificationResponse,
        withCompletionHandler completionHandler: @escaping () -> Void
    ) {
        let userInfo = response.notification.request.content.userInfo

        if let reminderId = userInfo["reminderId"] as? String {
            // Post notification to navigate to reminder
            NotificationCenter.default.post(
                name: .didTapReminderNotification,
                object: nil,
                userInfo: ["reminderId": reminderId, "action": response.actionIdentifier]
            )
        }

        completionHandler()
    }
}

// MARK: - Notification Names

extension Notification.Name {
    static let didTapReminderNotification = Notification.Name("didTapReminderNotification")
}
```

## Notification Category (for actions)

### iosApp/Notifications/ReminderNotificationCategory.swift
```swift
import UserNotifications

struct ReminderNotificationCategory {
    static let identifier = "REMINDER_CATEGORY"

    static func register() {
        let category = UNNotificationCategory(
            identifier: identifier,
            actions: [], // Actions will be added in F4.4
            intentIdentifiers: [],
            options: [.customDismissAction]
        )

        UNUserNotificationCenter.current().setNotificationCategories([category])
    }
}
```

## App Delegate Setup

### iosApp/AppDelegate.swift
```swift
import SwiftUI
import UserNotifications

class AppDelegate: NSObject, UIApplicationDelegate {
    func application(
        _ application: UIApplication,
        didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]? = nil
    ) -> Bool {
        // Register notification category
        ReminderNotificationCategory.register()

        // Set notification center delegate
        UNUserNotificationCenter.current().delegate = NotificationManager.shared

        return true
    }
}
```

## App Entry Point Update

### iosApp/RemindersApp.swift
```swift
import SwiftUI

@main
struct RemindersApp: App {
    @UIApplicationDelegateAdaptor(AppDelegate.self) var appDelegate
    @StateObject private var notificationManager = NotificationManager.shared

    var body: some Scene {
        WindowGroup {
            MainTabView()
                .environmentObject(notificationManager)
                .task {
                    // Request notification permission on first launch
                    if !notificationManager.isAuthorized {
                        _ = await notificationManager.requestAuthorization()
                    }
                }
        }
    }
}
```

## KMP Bridge Update for Notification Scheduling

### iosApp/KMP/KMPBridge.swift (additions)
```swift
import Foundation
import Shared

extension KMPBridge {
    // Called after creating a reminder
    func scheduleNotification(for reminder: Reminder) {
        NotificationManager.shared.scheduleNotification(for: reminder)
    }

    // Called after deleting or completing a reminder
    func cancelNotification(for reminderId: String) {
        NotificationManager.shared.cancelNotification(for: reminderId)
    }
}
```

## Integration with ViewModels

### Update AddEditReminderViewModel.swift
```swift
// In onSave() after successful save:
if !isEditMode {
    // New reminder - schedule notification
    NotificationManager.shared.scheduleNotification(for: newReminder)
} else {
    // Edited reminder - reschedule notification
    NotificationManager.shared.scheduleNotification(for: updatedReminder)
}
```

### Update HomeViewModel.swift
```swift
// When completing or deleting a reminder:
func onCompleteReminder(id: String) {
    NotificationManager.shared.cancelNotification(for: id)
    // ... existing completion logic
}

func onDeleteReminder(id: String) {
    NotificationManager.shared.cancelNotification(for: id)
    // ... existing deletion logic
}
```

## Deep Link Handling for Notification Taps

### iosApp/Navigation/DeepLinkHandler.swift
```swift
import Foundation
import Combine
import SwiftUI

class DeepLinkHandler: ObservableObject {
    @Published var pendingReminderId: String? = nil

    private var cancellables = Set<AnyCancellable>()

    init() {
        NotificationCenter.default.publisher(for: .didTapReminderNotification)
            .receive(on: DispatchQueue.main)
            .sink { [weak self] notification in
                if let reminderId = notification.userInfo?["reminderId"] as? String {
                    self?.pendingReminderId = reminderId
                }
            }
            .store(in: &cancellables)
    }

    func consumePendingReminder() -> String? {
        let id = pendingReminderId
        pendingReminderId = nil
        return id
    }
}
```

### Update HomeNavigationStack.swift
```swift
struct HomeNavigationStack: View {
    @State private var path = NavigationPath()
    @StateObject private var deepLinkHandler = DeepLinkHandler()

    var body: some View {
        NavigationStack(path: $path) {
            HomeScreen(
                onAddTapped: { path.append(AppRoute.addReminder) },
                onReminderTapped: { id in path.append(AppRoute.editReminder(reminderId: id)) }
            )
            .navigationDestination(for: AppRoute.self) { route in
                // ... existing destinations
            }
        }
        .onChange(of: deepLinkHandler.pendingReminderId) { reminderId in
            if let id = reminderId {
                path.append(AppRoute.editReminder(reminderId: id))
                _ = deepLinkHandler.consumePendingReminder()
            }
        }
    }
}
```

## Permission Request View (Optional)

### iosApp/Components/NotificationPermissionView.swift
```swift
import SwiftUI

struct NotificationPermissionView: View {
    @EnvironmentObject var notificationManager: NotificationManager
    @Environment(\.dismiss) var dismiss

    var body: some View {
        VStack(spacing: 24) {
            Image(systemName: "bell.badge")
                .font(.system(size: 60))
                .foregroundColor(.blue)

            Text("Enable Notifications")
                .font(.title2)
                .fontWeight(.semibold)

            Text("Get notified when your reminders are due so you never miss an important task.")
                .font(.body)
                .foregroundColor(.secondary)
                .multilineTextAlignment(.center)
                .padding(.horizontal)

            Button {
                Task {
                    _ = await notificationManager.requestAuthorization()
                    dismiss()
                }
            } label: {
                Text("Enable Notifications")
                    .fontWeight(.semibold)
                    .frame(maxWidth: .infinity)
            }
            .buttonStyle(.borderedProminent)
            .padding(.horizontal)

            Button("Maybe Later") {
                dismiss()
            }
            .foregroundColor(.secondary)
        }
        .padding()
    }
}
```

## Verification
```bash
# Open iosApp in Xcode and run

# Test steps:
# 1. Allow notification permission when prompted
# 2. Create a reminder for 1 minute in the future
# 3. Wait for notification to appear
# 4. Tap notification to open the app and navigate to reminder
# 5. Delete a reminder and verify notification is cancelled
# 6. Complete a reminder and verify notification is cancelled
# 7. Test notification appears when app is in foreground
```

## Files to Create/Modify
- `iosApp/iosApp/Notifications/NotificationManager.swift`
- `iosApp/iosApp/Notifications/ReminderNotificationCategory.swift`
- `iosApp/iosApp/AppDelegate.swift`
- `iosApp/iosApp/Navigation/DeepLinkHandler.swift`
- `iosApp/iosApp/Components/NotificationPermissionView.swift` (optional)
- Update `iosApp/iosApp/RemindersApp.swift`
- Update `iosApp/iosApp/Navigation/HomeNavigationStack.swift`
- Update `iosApp/iosApp/Screens/Edit/AddEditReminderViewModel.swift`
- Update `iosApp/iosApp/Screens/Home/HomeViewModel.swift`
